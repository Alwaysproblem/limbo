<!DOCTYPE HTML>
<!-- vim:filetype=html:textwidth=200:shiftwidth=4:softtabstop=4:expandtab
-->
<html lang="en">
<head>
    <meta charset="UTF-8"> 
    <title>Limited reasoner demo</title>

    <!--<link href="//fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">-->
    <style type="text/css">
        body { font-family: 'Open Sans', sans-serif; font-size: 140%; }
        p { text-align: justify; }
        i { font-weight: 600; font-style: normal; }

        h1       { font-size: 220%; }
        h2       { font-size: 170%; border-bottom: 1px solid #aaa; }

        #examples { font-family: inherit; font-weight: bold; font-size: inherit; }
        #parse-text { background-color: #eeeeee; font-family: monospace; font-size: 140%; border: 2px solid black; width: 95%; height: 70%; }
        #parse-text { background: repeating-linear-gradient( -45deg, #e5e5e5, #e5e5e5 10px, #eeeeee 10px, #eeeeee 20px); }
        #parse-button { font-family: inherit; font-weight: bold; font-size: inherit; }
        #parse-button {
            color: #eee;
            background:
                linear-gradient(27deg, #151515 5px, transparent 5px) 0 5px,
                linear-gradient(207deg, #151515 5px, transparent 5px) 10px 0px,
                linear-gradient(27deg, #222 5px, transparent 5px) 0px 10px,
                linear-gradient(207deg, #222 5px, transparent 5px) 10px 5px,
                linear-gradient(90deg, #1b1b1b 10px, transparent 10px),
                linear-gradient(#1d1d1d 25%, #1a1a1a 25%, #1a1a1a 50%, transparent 50%, transparent 75%, #242424 75%, #242424);
            background-color: #131313;
            background-size: 20px 20px;
        }
        #parse-button { display: block; margin-top: 2ex; margin-left: 25%; min-width: 25%; padding-top: 3ex; padding-bottom: 3ex; }

        #parse-output, #debug-output { width: 95%; min-height: 5ex; background-color: #dddddd; border: 2px solid black; }
        #parse-output, #debug-output { background: repeating-linear-gradient( 45deg, #e5e5e5, #e5e5e5 10px, #eeeeee 10px, #eeeeee 20px); }

        #parse-output { font-family: monospace; font-size: 140%; }
        #debug-output { font-family: monospace; font-size: 110%; }

        .announcement { font-family: font-family: monospace; font-weight: bold; white-space: pre-wrap; }
        .announcement div { display: inline-block; }
        .announcement .console,
        .announcement .parse-result,
        .announcement.failure .parse-remainder { display: block; }
        .announcement.success .parse-remainder { display: none; }

        .announcement .console,
        .announcement .split-level,
        .announcement .formula,
        .announcement .parse-result,
        .announcement .parse-remainder { color: black; font-weight: normal; }

        .announcement .split-level::after,
        .announcement .split-level::before,
        .announcement .formula::after,
        .announcement .formula::before,
        .announcement .parse-result::after,
        .announcement .parse-result::before,
        .announcement .parse-remainder::after,
        .announcement .parse-remainder::before { font-weight: bold; }

        .announcement.success *::after, .announcement.success *::before { color: green; }
        .announcement.failure *::after, .announcement.failure *::before { color: red; }

        .announcement.query .formula::before { content: "Query: "; }
        .announcement.query .formula::after { content: "  \2192  " }

        .announcement.success .result::after { content: "success" }
        .announcement.failure .result::after { content: "failure" }

        .announcement.overall.success .parse-result::before { display: block; content: "Success"; }
        .announcement.overall.failure .parse-result::before { display: block; content: "Failure:"; }
        .announcement.overall.failure .parse-remainder::before { display: block; content: "with remaining input:"; }

        ul.grammar { list-style-type: none; }
        ul.grammar.table { display: table; }
        ul.grammar.table li { display: table-row; }
        ul.grammar div.label { display: table-cell; padding-right: 1ex; }
        ul.grammar div.body { display: table-cell; }
        .code { font-family: monospace; font-weight: bold; }
        .metavariable { font-family: monospace; font-weight: normal; color: #800080; }
    </style>

    <script src="../jquery-3.1.1.min.js"></script>
    <script>window.jQuery || document.write('<script src="//ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js">\x3C/script>')</script>
    <script>
    function getParameterByName(name) {
        var url = window.location.href;
        name = name.replace(/[\[\]]/g, "\\$&");
        var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
            results = regex.exec(url);
        if (!results) return null;
        if (!results[2]) return '';
        return decodeURIComponent(results[2].replace(/\+/g, " "));
    }
    </script>

    <script>
    Module = {
        'print': function(msg) { printMsg(msg); },
        'printErr': function(msg) { printDebug(msg); },
    };
    </script>
    <script src="tui-js.js"></script>

    <script>
    /*
    var Module = null;

    function loadEmscripten(mem) {
        if (!mem) {
            mem = getParameterByName('mem');
        }
        if (!mem) {
            mem = 16;
        }
        mem *= 1024*1024;
        Module = {
            'print': function(msg) { printMsg(msg); },
            'printErr': function(msg) { printDebug(msg); },
            'TOTAL_MEMORY': mem,
        };
        src = 'tui-js.js';
        $('script[src="' + src + '"]').remove();
        $('<script>').attr('src', src).appendTo('head');
    }
    */
    </script>
</head>

<body>

<h1>Limited Reasoner Demo: Textual User Interface</h1>

<p>
<b>Quick start:</b> have a look at the "Problem Description", hit the "Click me!" button, and check the output under "Reasoning Results".
</p>

<p>
For further demos and details on the reasoner, <a href="../">click here</a>.
</p>

<h2>Problem Description</h2>

<p>
Load an example:
<select id="examples">
<option value="example-rich-father">Example: Rich Father</option>
<option value="example-unknown-father">Example: Unknown Father</option>
<option value="example-siblings">Example: Siblings</option>
<option value="example-veggie">Example: Veggie</option>
<option value="example-battleship-1x4">Example: Battleship 1x4</option>
<option value="example-battleship-4x4">Example: Battleship 4x4</option>
<option value="test-propositions">Test: Propositions</option>
<option value="test-functions">Test: Constants</option>
<option value="test-introspection-disjunction">Test: Introspection 1</option>
<option value="test-introspection-existential">Test: Introspection 2</option>
<option value="test-introspection-constant">Test: Introspection 3</option>
<option value="test-guarantee">Test: Guarantee</option>
<option value="test-control">Test: Control Structures</option>
<option value="test-rich-father">Test: Rich Father</option>
<option value="test-siblings">Test: Unknown Father</option>
<option value="test-veggie">Test: Veggie 1</option>
<option value="test-veggie-with-guarantee">Test: Veggie 2</option>
<!-- test-battleship-1x4 test is specificially for "my" computer as it assumes a specific "random" ship placement, which is different under Javascript due to different random numbers -->
<!-- <option value="test-battleship-1x4">Test: Battleship 1x4</option> -->
<option value="" style="color: #666;">none</option>
</select> <br />
If you like, you can edit the text. For help on the syntax, see <a href="#syntax">below</a>.
</p>

<textarea id="parse-text" cols="80" rows="20">
</textarea>

<input value="Click me!" type="button" id="parse-button" />

<script>
$(document).ready(function() {
    //loadEmscripten();
    $('#debug-toggle').click(function() { $('#debug-div').toggle(); return false; });
    //$('#enlarge-memory').click(function() { loadEmscripten(128); return false; });

    var select_ex = getParameterByName('ex');
    if (select_ex) {
        $('#examples option').filter(function() {
            return $(this).val().indexOf(select_ex) != -1;
        }).prop('selected', true);
    }

    justLoaded = true;
    $('#examples').change(function() {
        var file = null;
        $('#examples option:selected').each(function() { file = $(this).val(); });
        if (file) {
            $.ajax({
                url : file + '.lela',
                dataType: 'text',
                success: function(data) {
                    $('#parse-text').val(data.trim());
                    if (!justLoaded) {
                        scrollToShow($('#parse-button'));
                        $('#parse-button').focus();
                    }
                    justLoaded = false;
                }
            });
        } else {
            $('#parse-text').val("").focus();
        }
    }).change();

    $('#parse-button').click(function() {
        parse();
    });
});

function scrollToShow(e) {
    var currentTop = $(document).scrollTop();
    var currentBottom = $(document).scrollTop() + $(window).height();
    var goalTop = $(e).offset().top;
    var goalBottom = $(e).offset().top + $(e).outerHeight();
    var inDisplay = function(pos) { return currentTop <= pos && pos <= currentBottom; };
    var topOfScreen = function(pos) { return pos < currentTop; };
    var belowOfScreen = function(pos) { return pos > currentBottom; };
    var fitsIntoScreen = $(e).outerHeight() <= $(window).height();
    var goal;
    var timeout = 200;
    if (inDisplay(goalTop) && inDisplay(goalBottom)) {
        // No need to scroll.
    } else if (!inDisplay(goalTop) && belowOfScreen(goalTop) && fitsIntoScreen) {
        // Scroll so that bottom of element aligns with bottom of window.
        $('html, body').animate({ scrollTop: goalBottom - $(window).height() }, timeout);
    } else if (!inDisplay(goalTop)) {
        // Scroll so that top of element aligns with top of window.
        $('html, body').animate({ scrollTop: goalTop }, timeout);
    } else if (!inDisplay(goalBottom)) {
        // Scroll so that bottom of element aligns with bottom of window.
        $('html, body').animate({ scrollTop: goalBottom - $(window).height() }, timeout);
    }
}

var last_is_console = false;

function parse() {
    $('#parse-output').empty();
    $('#debug-output').empty();
    var text = $('#parse-text').val();
    var t0 = performance.now();
    Module.ccall('lela_parse', 'void', ['string'], [text]);
    var t1 = performance.now();
    printDebug("Parsing and reasoning took "+ Math.round(t1 - t0) +" milliseconds");
    scrollToShow($('#parse-output'));
}

function resultClass(r) { return r ? 'success' : 'failure'; }
function resultLabel(r) { return r ? 'Success' : 'Failure'; }

function announceQuery(phi, success) {
    $('#parse-output').append(
        '<li class="announcement query '+ resultClass(success)+'">'+
        '<div class="formula">'+ phi +'</div><div class="result"></div>'+
        '</li>');
}

function announceResult(success, msg, remainder) {
    $('#parse-output').append(
        '<li class="announcement overall '+ resultClass(success)+'">'+
        '<div class="parse-result">'+ msg +'</div>'+
        '<div class="parse-remainder">'+ remainder +'</div>'+
        '</li>');
}

function printMsg(msg) {
    if (msg.length == 0) {
        return;
    }
    if ($('#parse-output').last() == null || !$('#parse-output').last().hasClass('console')) {
        $('#parse-output').append(
            '<li class="announcement console">'+
            '<div class="message">'+ msg +'</div>'+
            '</li>');
    } else {
        $('#parse-output').children().last().append(msg);
    }
}

function printDebug(msg) {
    if (msg.length == 0) {
        return;
    }
    if (typeof msg.charCodeAt !== 'undefined') {
        var c = msg.charCodeAt(0);
        if ((65 <= c && c <= 90) || (97 <= c && c <= 122) || $('#debug-output').last() == null) {
            $('#debug-output').append('<li>'+ msg +'</li>');
        } else {
            $('#debug-output').children().last().append('<br />'+ msg);
        }
    }
}
</script>



<h2>Reasoning Results</h2>

<p>
Click the button above to let the reasoner do its work. It should report the results of the queries below.
Note that the reasoner brings the query formulas into a normal form (similar to negation normal form), so the printed formulas below may differ syntactically from your queries.
</p>

<ul id="parse-output">
</ul>

<p>
<a href="#debug-toggle" id="debug-toggle">Click here</a> to display/hide debug output.
<!--If more memory is needed (e.g., for some Sudokus), <a href="#enlarge-memory" id="enlarge-memory">click here</a> to enlarge.-->
</p>


<div id="debug-div" style="display: none;">
<h3>Debug Output</h3>

<p>The Javascript console output is displayed below.</p>

<ul id="debug-output">
</ul>
</div>



<h2 id="syntax">The Problem Description Language</h2>

<p>A problem description consists of four parts:</p>
<ol>
    <li> declarations of sorts, variables, standard names, and functions; </li>
    <li> optional abbreviations for formulas; </li>
    <li> the knowledge definition; </li>
    <li> queries. </li>
</ol>
<p>
The syntax of these segments is as follows, where <span class="code">this font</span> is a word of the the problem description language, and <span class="metavariable">this font</span> represents a meta-variable.
</p>

<p>
All sorts, variables, names, and function symbols must be declared before they are used.
Declarations are of the following form:
</p>
<ul class="grammar table">
    <li><div class="label">sort declaration:</div>
        <div class="body">
            <span class="code">Sort <span class="metavariable">sort</span></span>
        </div>
    </li>
    <li><div class="label">variable declaration:</div>
        <div class="body">
            <span class="code">Variable <span class="metavariable">x</span> -&gt; <span class="metavariable">sort</span></span> &nbsp;&nbsp;or&nbsp;&nbsp;
            <span class="code">Var <span class="metavariable">x</span> -&gt; <span class="metavariable">sort</span></span>
        </div>
    </li>
    <li><div class="label">name declaration:</div>
        <div class="body">
            <span class="code">Name <span class="metavariable">n</span> -&gt; <span class="metavariable">sort</span></span>
        </div>
    </li>
    <li><div class="label">function declaration:</div>
        <div class="body">
            <span class="code">Function <span class="metavariable">f</span>/<span class="metavariable">arity</span> -&gt; <span class="metavariable">sort</span></span> &nbsp;&nbsp;or&nbsp;&nbsp;
            <span class="code">Fun <span class="metavariable">f</span>/<span class="metavariable">arity</span> -&gt; <span class="metavariable">sort</span></span>
        </div>
    </li>
</ul>
<p>
where <span class="metavariable">sort</span>, <span class="metavariable">x</span>, <span class="metavariable">n</span>, <span class="metavariable">f</span> are identifiers and <span class="metavariable">arity</span> is a natural number &ge; 0.
An identifier is a sequence of lower- and upper-case letters, digits, underscore and dash symbols, with the first symbol being a letter or underscore.
No two sorts can have the same identifier.
No two variables, names, or functions can have the same identifier.
</p>

<p>
The following constructs are well-formed formulas:
<ul class="grammar table">
    <li><div class="label">literals:</div>
        <div class="body">
            <span class="code"><span class="metavariable">literal</span></span>
            &nbsp;&nbsp;as specified below
        </div>
    </li>
    <li><div class="label">negation:</div>
        <div class="body">
            <span class="code">!<span class="metavariable">formula</span></span>
            &nbsp;&nbsp;or&nbsp;&nbsp;
            <span class="code">~<span class="metavariable">formula</span></span>
        </div>
    </li>
    <li><div class="label">disjunction:</div>
        <div class="body">
            <span class="code"><span class="metavariable">formula<sub>1</sub></span> || <span class="metavariable">formula<sub>2</sub></span></span>
            &nbsp;&nbsp;or&nbsp;&nbsp;
            <span class="code"><span class="metavariable">formula<sub>1</sub></span> | <span class="metavariable">formula<sub>2</sub></span></span>
            &nbsp;&nbsp;or&nbsp;&nbsp;
            <span class="code"><span class="metavariable">formula<sub>1</sub></span> v <span class="metavariable">formula<sub>2</sub></span></span>
        </div>
    </li>
    <li><div class="label">conjunction:</div>
        <div class="body">
            <span class="code"><span class="metavariable">formula<sub>1</sub></span> &amp;&amp; <span class="metavariable">formula<sub>2</sub></span></span>
            &nbsp;&nbsp;or&nbsp;&nbsp;
            <span class="code"><span class="metavariable">formula<sub>1</sub></span> &amp; <span class="metavariable">formula<sub>2</sub></span></span>
            &nbsp;&nbsp;or&nbsp;&nbsp;
            <span class="code"><span class="metavariable">formula<sub>1</sub></span> ^ <span class="metavariable">formula<sub>2</sub></span></span>
        </div>
    </li>
    <li><div class="label">implication:</div>
        <div class="body">
            <span class="code"><span class="metavariable">formula<sub>1</sub></span> -&gt; <span class="metavariable">formula<sub>2</sub></span></span>
        </div>
    </li>
    <li><div class="label">equivalence:</div>
        <div class="body">
            <span class="code"><span class="metavariable">formula<sub>1</sub></span> &lt;-&gt; <span class="metavariable">formula<sub>2</sub></span></span>
        </div>
    </li>
    <li><div class="label">existential quantification:</div>
        <div class="body">
            <span class="code">Ex <span class="metavariable">x</span> <span class="metavariable">formula</span></span>
        </div>
    </li>
    <li><div class="label">universal quantification:</div>
        <div class="body">
            <span class="code">Fa <span class="metavariable">x</span> <span class="metavariable">formula</span></span>
        </div>
    </li>
    <li><div class="label">knowledge modality:</div>
        <div class="body">
            <span class="code">Know&lt;<span class="metavariable">split-level</span>&gt; <span class="metavariable">formula</span></span>
            &nbsp;&nbsp;or&nbsp;&nbsp;
            <span class="code">K&lt;<span class="metavariable">split-level</span>&gt; <span class="metavariable">formula</span></span>
        </div>
    </li>
    <li><div class="label">considering-possible modality:</div>
        <div class="body">
            <span class="code">Cons&lt;<span class="metavariable">split-level</span>&gt; <span class="metavariable">formula</span></span>
            &nbsp;&nbsp;or&nbsp;&nbsp;
            <span class="code">M&lt;<span class="metavariable">split-level</span>&gt; <span class="metavariable">formula</span></span>
        </div>
    </li>
    <li><div class="label">conditional belief modality:</div>
        <div class="body">
            <span class="code">Bel&lt;<span class="metavariable">split-level<sub>1</sub></span>,<span class="metavariable">split-level<sub>2</sub></span>&gt; <span class="metavariable">formula<sub>1</sub></span> ==&gt; <span class="metavariable">formula<sub>2</sub></span></span>
            &nbsp;&nbsp;or<br />
            <span class="code">B&lt;<span class="metavariable">split-level<sub>1</sub></span>,<span class="metavariable">split-level<sub>2</sub></span>&gt; <span class="metavariable">formula<sub>1</sub></span> ==&gt; <span class="metavariable">formula<sub>2</sub></span></span>
        </div>
    </li>
    <li><div class="label">guarantee-consistency modality:</div>
        <div class="body">
            <span class="code">Guarantee <span class="metavariable">formula</span></span>
            &nbsp;&nbsp;or&nbsp;&nbsp;
            <span class="code">G <span class="metavariable">formula</span></span>
        </div>
    </li>
    <li><div class="label">override operator precedence:</div>
        <div class="body">
            <span class="code">(<span class="metavariable">formula</span>)</span>
        </div>
    </li>
    <li><div class="label">formula abbreviations:</div>
        <div class="body">
            <span class="code"><span class="metavariable">formula-id</span></span>
            &nbsp;&nbsp;where the value of <span class="metavariable">formula-id</span> must have been defined as specified below
        </div>
    </li>
</ul>
<p>
A <span class="metavariable">literal</span> is of the following form:
</p>
<ul class="grammar table">
    <li><div class="label">equality:</div>
        <div class="body">
            <span class="code"><span class="metavariable">t<sub>1</sub></span> == <span class="metavariable">t<sub>2</sub></span></span> &nbsp;&nbsp;or&nbsp;&nbsp;
            <span class="code"><span class="metavariable">t<sub>1</sub></span> = <span class="metavariable">t<sub>2</sub></span></span>
        </div>
    </li>
    <li><div class="label">inequality:</div>
        <div class="body">
            <span class="code"><span class="metavariable">t<sub>1</sub></span> != <span class="metavariable">t<sub>2</sub></span></span> &nbsp;&nbsp;or&nbsp;&nbsp;
            <span class="code"><span class="metavariable">t<sub>1</sub></span> /= <span class="metavariable">t<sub>2</sub></span></span>
        </div>
    </li>
</ul>
<p>
where <span class="metavariable">t<sub>i</sub></span> is a term.
A term is either the identifier of a previously declared variable <span class="metavariable">x</span>, a previously declared standard name <span class="metavariable">n</span>, or a compound term <span class="code"><span class="metavariable">f</span>(<span class="metavariable">t'<sub>1</sub></span>, <span class="metavariable">...</span>, <span class="metavariable">t'<sub>k</sub></span>)</span> where a previously declared function symbol <span class="metavariable">f</span> of arity <span class="metavariable">k</span> is applied to other terms <span class="metavariable">t'<sub>i</sub></span>.
When <span class="metavariable">f</span> is a constant symbol (that is, has arity 0), the brackets may be omitted.
Variables in the KB are implicitly universally quantified.
</p>
<p>
A <span class="metavariable">split-level</span> is a natural number &ge; 0 that indicates how much reasoning effort the reasoner can spend on proving the <span class="metavariable">formula</span> in the modality.
The modal operator <span class="code">Know</span> is the usual knowledge modality, <span class="code">Cons</span> means a formula is considered possible (that is, its negation is not known), and <span class="code">Bel</span> is conditional belief.
All three operators are sound but incomplete with respect to the unlimited logic of only-knowing/believing.
The <span class="metavariable">split-level</span> can have two different meanings.
The one within <span class="code">Know</span> and the first parameter of <span class="code">Bel</span> specify how many terms may be split.
A split means to select a term <span class="code">f(n<sub>1</sub>,...,n<sub>l</sub>)</span> and consider all possible denotations of that term; that is, the reasoner tests all (relevant) assignments for these terms.
The <span class="metavariable">split-level</span> in <span class="code">Cons</span> and the second parameter of <span class="code">Bel</span>, on the other hand, specify how many terms can be freely assigned a value, which means to select a (possibly non-ground) term <span class="code">f(t<sub>1</sub>,...,t<sub>l</sub>)</span> and fix its denotation.
</p>
<p>
Within the scope of the <span class="code">Guarantee</span> modality the reasoner is allowed to assume the knowledge base is consistent, which may improve performance because it limits the splitting search space.
</p>
<p>
Operator precedence is as follows: 
equivalence &lt; implication &lt; disjunction &lt; conjunction &lt; negation, quantifiers, modalities &lt; brackets.
Note the maximal precedence of quantifiers and modalities.
Use brackets to expand the scope of a quantifier or a modal operator.
For example, to say that <span class="code"><span class="metavariable">formula<sub>1</sub></span> || <span class="metavariable">formula<sub>2</sub></span></span> is known, write <span class="code">Know&lt;<span class="metavariable">split-level</span>&gt; (<span class="metavariable">formula<sub>1</sub></span> || <span class="metavariable">formula<sub>2</sub></span>)</span>.
The formula <span class="code">Know&lt;<span class="metavariable">split-level</span>&gt; <span class="metavariable">formula<sub>1</sub></span> || <span class="metavariable">formula<sub>2</sub></span></span> by contrast says that either <span class="code"><span class="metavariable">formula<sub>1</sub></span></span> is known or <span class="code"><span class="metavariable">formula<sub>2</sub></span></span> is true.
</p>

<p>
Any formula abbreviation <span class="metavariable">formula-id</span> must be defined before use:
</p>
<ul class="grammar">
    <li><span class="code">Let <span class="metavariable">formula-id</span> := <span class="metavariable">formula</span></span></li>
</ul>
<p>
where <span class="metavariable">formula-id</span> is the identifier by which the formula can later be referred.
<span class="metavariable">formula-id</span> can be re-assigned new values.
</p>

<p>
The knowledge base consists of a sequence of statements of the following form:
</p>
<ul class="grammar">
    <li><span class="code">KB:&nbsp;<span class="metavariable">formula</span></span></li>
</ul>
<p>
where one of the following syntactic conditions must be satisfied:
</p>
<ol>
    <li><span class="metavariable">formula</span> contains no modal operators and its normal form (&approx; prenex-NNF) is a clause without existentially quantified variables;</li>
    <li><span class="metavariable">formula</span> is of the form <span class="code">Know&lt;<span class="metavariable">split-level</span>&gt; <span class="metavariable">formula'</span></span> where <span class="metavariable">formula'</span> satisfies to condition 1 (the <span class="metavariable">split-level</span> is ignored);</li>
    <li><span class="metavariable">formula</span> is of the form <span class="code">Bel&lt;<span class="metavariable">split-level<sub>1</sub></span>,<span class="metavariable">split-level<sub>2</sub></span>&gt; <span class="metavariable">formula<sub>1</sub></span> ==&gt; <span class="metavariable">formula<sub>2</sub></span></span> where <span class="code">!<span class="metavariable">formula<sub>1</sub></span> || <span class="metavariable">formula<sub>2</sub></span></span> satisfies to condition 1 (the <span class="metavariable">split-level</span>s affect how faithful the induced system of spheres is to the unlimited logic).</li>
</ol>
<p>
Free variables in <span class="metavariable">formula</span> in KB definitions are implicitly universally quantified.
The formal definition of the normal form is tedious, but the idea is this: push negations inwards but not into clauses, and pull quantifiers out of clauses.
The rationale is to create new clauses (while avoiding the exponential blowup of a full CNF).
Additionally, terms are flattened so that no two function symbols occur in a any literal.
For instance, a disjunction <span class="code">KB:&nbsp;<span class="metavariable">literal<sub>1</sub></span> || <span class="metavariable">...</span> || <span class="metavariable">literal<sub>k</sub></span></span> meets this requirement trivially.
Implications are also allowed, provided that the negation of the antecedent as well as the consequent meet above form, as does <span class="code">KB:&nbsp;Ex <span class="metavariable">x</span> (<span class="metavariable">literal<sub>1</sub></span> &amp;&amp; <span class="metavariable">literal<sub>2</sub></span>) -&gt; (<span class="metavariable">literal<sub>3</sub></span> || <span class="metavariable">literal<sub>4</sub></span>)</span>.
</p>

<p>
Queries are of the form:
</p>
<ul class="grammar">
    <li><span class="code">Query: <span class="metavariable">formula</span></span></li>
    <li><span class="code">Assert: <span class="metavariable">formula</span></span></li>
    <li><span class="code">Refute: <span class="metavariable">formula</span></span></li>
</ul>
<p>
where <span class="metavariable">formula</span> is subjective, which means functions must not occur outside of modal operators (but variables, names, quantifiers, etc. may).
The <span class="code">Assert</span> and <span class="code">Refute</span> versions differ from the <span class="code">Query</span> version in that they yield a error when the query does not come out true or false, respectively; this is useful for automated testing.
</p>

<p>
Procedure calls are of the form <span class="code">Call:&nbsp;<span class="metavariable">proc</span>(<span class="metavariable">arg<sub>1</sub></span>,<span class="metavariable">...</span>,<span class="metavariable">arg<sub>k</sub></span>)</span>.
In particular, they include:
</p>
<ul class="grammar">
    <li><span class="code">Call:&nbsp;enable_query_logging()</span> and <span class="code">Call:&nbsp;disable_query_logging()</span> to disable logging of evaluated queries in the main output</li>
    <li><span class="code">Call:&nbsp;print_kb()</span> to print the current setups to debug output</li>
    <li><span class="code">Call:&nbsp;print(<span class="metavariable">t<sub>1</sub></span>,<span class="metavariable">...</span>,<span class="metavariable">t<sub>k</sub></span>)</span> to print terms to main output</li>
</ul>

<p>
Furthermore simple control structures are allowed: if-then-else, while-loops, and for-loops.
See the Battleship and Sudoku code for examples.
</p>

<p>
C-style single line comments are supported as well: <span class="code">//&nbsp;<span class="metavariable">rest of line is comment</span></span>.
</p>

<p>
<b>Bug(s):</b> There's are two known bugs regarding the <span class="code">M&lt;k&gt;</span> operator.
For one thing, within <span class="code">G</span> it's too aggressive and thus finds inconsistencies it shouldn't.
For another, inconsistencies due to <span class="code">Fa x f(...) /= x</span> clauses are not detected at the moment.
Fixes shouldn't be too difficult, will be coming soon.
</p>

</body>
</html>

