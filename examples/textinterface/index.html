<!DOCTYPE HTML>
<html lang="en">
<head>
    <meta charset="UTF-8"> 
    <title>Limited reasoner demo</title>

    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
    <style type="text/css">
        body { font-family: 'Open Sans', sans-serif; font-size: 140%; }
        p { text-align: justify; }

        h1       { font-size: 220%; }
        h2       { font-size: 170%; border-bottom: 1px solid #aaa; }

        #parse-text { background-color: #eeeeee; font-family: monospace; font-size: 140%; border: 2px solid black; width: 95%; height: 70%; }
        #parse-text { background: repeating-linear-gradient( -45deg, #e5e5e5, #e5e5e5 10px, #eeeeee 10px, #eeeeee 20px); }
        #parse-button { background-color: black; color: #eee; font-family: inherit; font-weight: bold; font-size: 100%; margin-top: 2ex; margin-left: 25%; min-width: 25%; padding-top: 3ex; padding-bottom: 3ex; }
        #parse-button {
            background:
                linear-gradient(27deg, #151515 5px, transparent 5px) 0 5px,
                linear-gradient(207deg, #151515 5px, transparent 5px) 10px 0px,
                linear-gradient(27deg, #222 5px, transparent 5px) 0px 10px,
                linear-gradient(207deg, #222 5px, transparent 5px) 10px 5px,
                linear-gradient(90deg, #1b1b1b 10px, transparent 10px),
                linear-gradient(#1d1d1d 25%, #1a1a1a 25%, #1a1a1a 50%, transparent 50%, transparent 75%, #242424 75%, #242424);
            background-color: #131313;
            background-size: 20px 20px;
        }

        #output, #debug-output { width: 95%; min-height: 5ex; background-color: #dddddd; border: 2px solid black; }
        #output, #debug-output { background: repeating-linear-gradient( 45deg, #e5e5e5, #e5e5e5 10px, #eeeeee 10px, #eeeeee 20px); }

        #output { font-family: monospace; font-size: 140%; }
        #debug-output { font-family: monospace; font-size: 110%; }

        .announcement { font-family: font-family: monospace; font-weight: bold; white-space: pre-wrap; }
        .announcement div { display: inline-block; }

        .announcement .split-level,
        .announcement .formula { color: black; font-weight: normal; }

        .announcement .split-level::after,
        .announcement .split-level::before,
        .announcement .formula::after,
        .announcement .formula::before { font-weight: bold; }

        .announcement.success *::after, .announcement.success *::before, .announcement.success.overall * { color: green; }
        .announcement.failure *::after, .announcement.failure *::before, .announcement.failure.overall * { color: red; }

        .announcement.entailment  .split-level::before { content: "Entails    (" }
        .announcement.consistency .split-level::before { content: "Consistent (" }

        .announcement .split-level::after { content: ", " }
        .announcement .result::before { content: ")  \2192  " }

        .announcement.success .result::after { content: "success" }
        .announcement.failure .result::after { content: "failure" }

        .code { font-family: monospace; font-weight: bold; }
        .metavariable { font-family: monospace; font-weight: bold; color: green; }
    </style>

    <script src="lela.js"></script>
</head>

<body onload="initPage()">

<h1>Limited Reasoner Demo: Text Interface</h1>

<p>
This is demo of a limited reasoner for <b>decidable reasoning in first-order knowledge bases</b>.
</p>

<p>
<b>Quick start:</b> have a look at the "Problem Description", hit the "Click me!" button, and check the output under "Reasoning Results".
</p>

<p>
Also have a look at the <a href="../mw/" target="_blank">the other demo: minesweeper</a>.
</p>

<h2>Problem Description</h2>

<p>
An example problem description is preset.
If you like, change it; for help on the syntax, see <a href="#syntax">below</a>.
When you're done, click the button to run the reasoner.
</p>

<form>
<textarea id="parse-text" cols="80" rows="20">
Sort ENTITY;
Sort BOOL;

Variable x -> ENTITY;
Variable y -> ENTITY;

Name Jesus -> ENTITY;
Name Mary -> ENTITY;
Name Joe -> ENTITY;
Name HolyGhost -> ENTITY;
Name God -> ENTITY;
Name True -> BOOL;

Function fatherOf/1 -> ENTITY;
Function motherOf/1 -> ENTITY;
Function is_mortal/1 -> BOOL;

KB (Mary == motherOf(Jesus));
KB (HolyGhost == fatherOf(Jesus) || God == fatherOf(Jesus) || Joe == fatherOf(Jesus));
KB (is_mortal(Mary) == True);
KB (is_mortal(Joe) == True);
KB (fatherOf(Jesus) != x || x == Joe || is_mortal(x) != True);

Entails (0, HolyGhost == fatherOf(Jesus) || God == fatherOf(Jesus) || Joe == fatherOf(Jesus));

Let phi := Ex x (x == fatherOf(Jesus));
Entails (0, phi);
Entails (1, phi);

Let phi := HolyGhost == fatherOf(Jesus);
Consistent (0, phi);
Consistent (1, phi);

Entails (0, HolyGhost == fatherOf(Jesus) &amp;&amp; God == fatherOf(Jesus) || Joe == fatherOf(Jesus));

Let phi := motherOf(Jesus) == fatherOf(Jesus);
Entails    (0, phi);
Consistent (0, phi);
Entails    (0, !phi);
Consistent (0, !phi);
Consistent (1, !phi);

Entails (0, is_mortal(motherOf(Jesus)) == True);

Let phi := is_mortal(fatherOf(Jesus)) == True;
Consistent (1, phi);
Consistent (1, !phi);
</textarea>

<br />

<input value="Click me!" type="button" id="parse-button" onclick="parse()" />
</form>

<script>
function clearDiv(id) {
    var output = document.getElementById(id);
    while (output.firstChild) {
        output.removeChild(output.firstChild);
    }
}

function parse() {
    clearDiv('output');
    clearDiv('debug-output');
    var text = document.getElementById('parse-text').value;
    var t0 = performance.now();
    Module.ccall('lela_parse', 'void', ['string'], [text]);
    var t1 = performance.now();
    console.log("Parsing and reasoning took "+ Math.round(t1 - t0) +" milliseconds");
    var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
    if (isFirefox) {
        document.getElementById('output').scrollIntoView({block: "end", behavior: "smooth"});
    } else {
        document.getElementById('output').scrollIntoView(false);
    }
}

function resultClass(r) {
    return r ? 'success' : 'failure';
}

function resultLabel(r) {
    return r ? 'Success' : 'Failure';
}

function announceEntailment(k, phi, success) {
    //alert("Entails ("+ k +", "+ phi +") = "+ success);
    var li = document.createElement('li');
    li.className = 'announcement entailment '+ resultClass(success);
    li.innerHTML = '<div class="split-level">'+ k +'</div><div class="formula">'+ phi +'</div><div class="result"></div>';
    document.getElementById('output').appendChild(li);
}

function announceConsistency(k, phi, success) {
    //alert("Consistent ("+ k +", "+ phi +") = "+ success);
    var li = document.createElement('li');
    li.className = 'announcement consistency '+ resultClass(success);
    li.innerHTML = '<div class="split-level">'+ k +'</div><div class="formula">'+ phi +'</div><div class="result"></div>';
    document.getElementById('output').appendChild(li);
}

function announceResult(success, msg) {
    //alert("Success = "+ success +", msg = "+ msg);
    var li = document.createElement('li');
    li.className = 'announcement overall '+ resultClass(success);
    li.innerHTML = '<div class="parser-result">Parser end result: '+ resultLabel(success) +' ('+ msg +')</div>';
    document.getElementById('output').appendChild(li);
}

function redirectConsole() {
    if (typeof console  != "undefined") {
        if (typeof console.log != 'undefined') {
            console.olog = console.log;
        } else {
            console.olog = function() {};
        }
    }
    console.log = function(message) {
        console.olog(message);
        var debug_output = document.getElementById('debug-output');
        if (message.length == 0) {
            return;
        }
        var c = message.charCodeAt(0);
        if ((65 <= c && c <= 90) || (97 <= c && c <= 122) || debug_output.lastChild == null) {
            var li = document.createElement('li');
            li.innerHTML = message;
            debug_output.appendChild(li);
        } else {
            var li = debug_output.lastChild;
            li.innerHTML += '<br />' + message;
        }
    };
    console.error = console.debug = console.info = console.log;
}

function initPage() {
    redirectConsole();
    var text = document.getElementById('parse-text');
    text.focus();
    //text.setSelectionRange(0, text.value.length);
}

function toggleDisplay(id) {
    var e = document.getElementById(id);
    if (e != null) {
        if (e.style.display != "none") {
            e.style.display = "none";
        } else {
            e.style.display = "block";
        }
    }
}
</script>



<h2>Reasoning Results</h2>

<p>
Click the button above to let the reasoner do its work. It should report the results of the queries below.
Note that the reasoner brings the query formulas into a normal form (similar to negation normal form), so the printed formulas below may differ syntactically from your queries.
</p>

<ul id="output">
</ul>

<p><a href="javascript:toggleDisplay('debug-div');">Click here</a> to display/hide debug output.</p>


<div id="debug-div" style="display: none;">
<h3>Debug Output</h3>

<p>The Javascript console output is displayed below.</p>

<ul id="debug-output">
</ul>
</div>



<h2>About the Reasoner</h2>

<p>
The logical language features functions and equality, first-order quantification, standard names, and sorts.
(Predicates are not built-in but can be simulated with no overhead using boolean functions.)
Knowledge bases are restricted to be in clausal form with only universally quantified variables &ndash; these KBs are called proper<sup>+</sup>.
(Existentially quantified variables in the knowledge base can be simulated with functions.)
Queries are not subject to any syntactic restriction.
</p>

<p>
Decision procedures for sound entailment [KR-2016] and sound consistency [ECAI-2016] are implemented.
Future work are the conditional beliefs [ECAI-2016] (should be easy), actions [KR-2014] [ (as a preprocessing step), and introspection [IJCAI-2013].
</p>

<p>
The reasoner is written in C++.
The code is available at <a href="https://www.github.com/schwering/lela">github.com/schwering/lela</a>.
This demo is compiled by <a href="http://emscripten.org">emscripten</a>, which compiles C++ to Javascript.
The performance of the Javascript is about 10&times; slower than the native performance (on my computer, anyway).
(Which is funny, it should be only about 2&times; slower according to the times reported at the emscripten website.)
</p>

<p>
Please report bugs to <a href="mailto:c.schwering@unsw.edu.au">c.schwering@unsw.edu.au</a>.
</p>



<h2 id="syntax">The Problem Description Language</h2>

<p>A problem description consists of four parts:</p>
<ol>
    <li> declarations of sorts, variables, (standard) names, and functions; </li>
    <li> the knowledge definition; </li>
    <li> optional abbreviations for formulas; </li>
    <li> entailment and/or consistency queries. </li>
</ol>
<p>
The syntax of these segments is as follows, where <span class="code">this font</span> is a word the problem description language, and <span class="metavariable">this font</span> represents a meta-variable.
</p>

<p>
All sorts, variables, names, and function symbols must be declared before they are used.
A declaration of a sort is of the form <span class="code">Sort <span class="metavariable">id</span>;</span>, where <span class="metavariable">id</span> is the identifier of the sort.
A declaration of a variable is of the form <span class="code">Variable <span class="metavariable">id</span> -&gt; <span class="metavariable">sort-id</span>;</span> or <span class="code">Var <span class="metavariable">id</span> -&gt; <span class="metavariable">sort-id</span>;</span>, where <span class="metavariable">id</span> is the identifier of the variable and <span class="metavariable">sort-id</span> is the identifier of a previously declared sort.
A declaration of a (standard) name is of the form <span class="code">Name <span class="metavariable">id</span> -&gt; <span class="metavariable">sort-id</span>;</span>, where <span class="metavariable">id</span> is the identifier of the name and <span class="metavariable">sort-id</span> is the identifier of a previously declared sort.
A declaration of a function symbol is of the form <span class="code">Function <span class="metavariable">id</span>/<span class="metavariable">arity</span> -&gt; <span class="metavariable">sort-id</span>;</span> or <span class="code">Fun <span class="metavariable">id</span>/<span class="metavariable">arity</span> -&gt; <span class="metavariable">sort-id</span>;</span>, where <span class="metavariable">id</span> is the identifier of the function symbol, <span class="metavariable">arity</span> &ge; 0 is its arity, and <span class="metavariable">sort-id</span> is the identifier of a previously declared sort.
An identifier must start with a lower- or upper-case letter and may be followed by further letters, digits, or underscore symbols.
No identifier may be used twice to denote a variable, name, or function.
</p>

<p>
The knowledge base consists of a sequence of clauses, each of which is written as <span class="code">KB&nbsp;(<span class="metavariable">literal<sub>1</sub></span> || <span class="metavariable">...</span> || <span class="metavariable">literal<sub>k</sub></span>);</span>, where <span class="metavariable">literal<sub>i</sub></span> denotes a literal.
The sequence of literals may also be empty, that is, <span class="code">KB&nbsp;();</span> or there may be just one literal, that is, <span class="code">KB&nbsp;(<span class="metavariable">literal<sub>1</sub></span>);</span>.
Every <span class="metavariable">literal<sub>i</sub></span> is of the form <span class="metavariable"><span class="metavariable">t<sub>1</sub></span> == <span class="metavariable">t<sub>2</sub></span></span> or <span class="metavariable"><span class="metavariable">t<sub>1</sub></span> != <span class="metavariable">t<sub>2</sub></span></span>, where <span class="metavariable">t<sub>i</sub></span> is a term.
A term is either the identifier of a previously declared variable, a (standard) name, or a function symbol <span class="metavariable">f</span> applied to other terms <span class="metavariable">t'<sub>i</sub></span>, written <span class="code"><span class="metavariable">f</span>(<span class="metavariable">t'<sub>1</sub></span>, <span class="metavariable">...</span>, <span class="metavariable">t'<sub>k</sub></span>)</span>.
When <span class="metavariable">f</span> is a constant symbol (that is, has arity 0), the brackets may be omitted.
Variables in the KB are implicitly universally quantified.
</p>

<p>
For convenience, abbreviations for formulas can be defined.
The syntax for that is <span class="code">Let <span class="metavariable">id</span> := <span class="metavariable">formula</span>;</span>, where <span class="metavariable">id</span> is the identifier by which the formula can later be referred.
The set of formulas includes
literals as defined above,
negations <span class="code">!<span class="metavariable">formula</span></span>, 
conjunctions <span class="code"><span class="metavariable">formula<sub>1</sub></span> &amp;&amp; <span class="metavariable">formula<sub>2</sub></span></span>,
disjunctions <span class="code"><span class="metavariable">formula<sub>1</sub></span> || <span class="metavariable">formula<sub>2</sub></span></span>,
universal quantifiers <span class="code">Fa <span class="metavariable">x</span> <span class="metavariable">formula</span></span>, and
existential quantifiers <span class="code">Ex <span class="metavariable">x</span> <span class="metavariable">formula</span></span>,
where <span class="metavariable">x</span> is the identifier of some previously declared variable.
Formulas can be put in brackets, <span class="code">(<span class="metavariable">formula</span>)</span>.
Conjunction binds stronger than disjunctions, and the scope of negation and quantifiers is minimal; use brackets to increase the scope.
Finally, <span class="metavariable">formula</span> may also be a previously defined identifier of a formula abbreviation.
</p>

<p>
Finally, queries are of the form 
<span class="code">Entails&nbsp;(<span class="metavariable">k</span>, <span class="metavariable">formula</span>);</span> or
<span class="code">Consistent&nbsp;(<span class="metavariable">k</span>, <span class="metavariable">formula</span>);</span>, where <span class="metavariable">k</span> &ge; 0 is a natural number that denotes the reasoning effort and <span class="metavariable">formula</span> is a formula as defined above.
Both entailment and consistency queries are sound but incomplete with respect to classical logic.
The reasoning effort is measured in case splits (a split means to select a term <span class="code">f(n<sub>1</sub>,...,n<sub>l</sub>)</span> and consider all possible denotations of that term) in entailment queries, and as term assignments (an assignment means to select a term <span class="code">f(t<sub>1</sub>,...,t<sub>l</sub>)</span> and fix their denotation) in consistency queries.
</p>

<p>
The lexer and parser are hand-written (recursive descent) for this demo and hardly tested.
Let's just hope it works &#9786;.
</p>

<h2>References</h2>
<ul>
    <li>
        Lakemeyer and Levesque. Decidable Reasoning in a Logic of Limited Belief with Function Symbols. KR 2016.
        <a href="https://kbsg.rwth-aachen.de/sites/kbsg/files/LakemeyerLevesque2016.pdf">PDF</a></li>
    <li>
        Schwering and Lakemeyer. Decidable Reasoning in a First-Order Logic of Limited Conditional Belief. ECAI 2016.
        <a href="https://kbsg.rwth-aachen.de/sites/kbsg/files/SchweringLakemeyer2016.pdf">PDF</a>
    </li>
    <li>
        Lakemeyer and Levesque. Decidable Reasoning in a Fragment of the Epistemic Situation Calculus. KR 2014.
        <a href="https://pdfs.semanticscholar.org/8ac9/a2955895cd391ec2b62d8210ee8206979f4a.pdf">PDF</a>
    </li>
    <li>
        Lakemeyer and Levesque. Decidable Reasoning in a Logic of Limited Belief with Introspection and Unknown Individuals. IJCAI 2013.
        <a href="https://pdfs.semanticscholar.org/387c/951016c68aaf8ce36bb87e5ea4d1ef42405d.pdf">PDF</a>
    </li>
</ul>

</body>
</html>

