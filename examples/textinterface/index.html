<!DOCTYPE HTML>
<!-- vim:filetype=html:textwidth=200:shiftwidth=4:softtabstop=4:expandtab
-->
<html lang="en">
<head>
    <meta charset="UTF-8"> 
    <title>Limited reasoner demo</title>

    <link href="//fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
    <style type="text/css">
        body { font-family: 'Open Sans', sans-serif; font-size: 140%; }
        p { text-align: justify; }

        h1       { font-size: 220%; }
        h2       { font-size: 170%; border-bottom: 1px solid #aaa; }

        #parse-text { background-color: #eeeeee; font-family: monospace; font-size: 140%; border: 2px solid black; width: 95%; height: 70%; }
        #parse-text { background: repeating-linear-gradient( -45deg, #e5e5e5, #e5e5e5 10px, #eeeeee 10px, #eeeeee 20px); }
        #parse-button { display: block; background-color: black; color: #eee; font-family: inherit; font-weight: bold; font-size: 100%; margin-top: 2ex; margin-left: 25%; min-width: 25%; padding-top: 3ex; padding-bottom: 3ex; }
        #parse-button {
            background:
                linear-gradient(27deg, #151515 5px, transparent 5px) 0 5px,
                linear-gradient(207deg, #151515 5px, transparent 5px) 10px 0px,
                linear-gradient(27deg, #222 5px, transparent 5px) 0px 10px,
                linear-gradient(207deg, #222 5px, transparent 5px) 10px 5px,
                linear-gradient(90deg, #1b1b1b 10px, transparent 10px),
                linear-gradient(#1d1d1d 25%, #1a1a1a 25%, #1a1a1a 50%, transparent 50%, transparent 75%, #242424 75%, #242424);
            background-color: #131313;
            background-size: 20px 20px;
        }

        #parse-output, #debug-output { width: 95%; min-height: 5ex; background-color: #dddddd; border: 2px solid black; }
        #parse-output, #debug-output { background: repeating-linear-gradient( 45deg, #e5e5e5, #e5e5e5 10px, #eeeeee 10px, #eeeeee 20px); }

        #parse-output { font-family: monospace; font-size: 140%; }
        #debug-output { font-family: monospace; font-size: 110%; }

        .announcement { font-family: font-family: monospace; font-weight: bold; white-space: pre-wrap; }
        .announcement div { display: inline-block; }

        .announcement .split-level,
        .announcement .formula { color: black; font-weight: normal; }

        .announcement .split-level::after,
        .announcement .split-level::before,
        .announcement .formula::after,
        .announcement .formula::before { font-weight: bold; }

        .announcement.success *::after, .announcement.success *::before, .announcement.success.overall * { color: green; }
        .announcement.failure *::after, .announcement.failure *::before, .announcement.failure.overall * { color: red; }

        .announcement.entailment  .split-level::before { content: "Entails    (" }
        .announcement.consistency .split-level::before { content: "Consistent (" }

        .announcement .split-level::after { content: ", " }
        .announcement .result::before { content: ")  \2192  " }

        .announcement.success .result::after { content: "success" }
        .announcement.failure .result::after { content: "failure" }

        ul.grammar { list-style-type: none; }
        .code { font-family: monospace; font-weight: bold; }
        .metavariable { font-family: monospace; font-weight: normal; color: #800080; }
    </style>

    <script src="jquery-3.1.1.min.js"></script>
    <script src="lela.js"></script>
</head>

<body>

<h1>Limited Reasoner Demo: Text Interface</h1>

<p>
<b>Quick start:</b> have a look at the "Problem Description", hit the "Click me!" button, and check the output under "Reasoning Results".
</p>

<p>
Also have a look at the <a href="../minesweeper/" target="_blank">the other demo: minesweeper</a>.
</p>

<h2>Problem Description</h2>

<p>
Load an example problem description:
<select id="examples">
<option value="example-1.txt" selected="selected">Unknown Father</option>
<option value="assertions-1.txt">Unknown Father (with assertions)</option>
<option value="">none</option>
</select> <br />
If you like, you can edit the text. For help on the syntax, see <a href="#syntax">below</a>.
</p>

<textarea id="parse-text" cols="80" rows="20">
</textarea>

<input value="Click me!" type="button" id="parse-button" />

<script>
$(document).ready(function() {
   redirectConsole();

    $('#debug-toggle').click(function(){ $('#debug-div').toggle(); return false; });

    $('#examples').change(function() {
        var file = null;
        $('#examples option:selected').each(function() { file = $(this).val(); });
        if (file) {
            $.ajax({
                url : file,
                dataType: 'text',
                success: function(data) {
                    $('#parse-text').val(data);
                    scrollToBottom($('#parse-button'));
                    $('#parse-button').focus();
                }
            });
        } else {
            $('#parse-text').val("").focus();
        }
    }).change();

    $('#parse-button').click(function() {
        parse();
    });
});

function scrollToBottom(e) {
    var wHeight = $(window).height();
    var eOffset = $(e).offset().top;
    var eHeight = $(e).outerHeight();
    $('html, body').animate({ scrollTop: eOffset - wHeight + eHeight }, 200);
}

function parse() {
    $('#parse-output').empty();
    $('#debug-output').empty();
    var text = $('#parse-text').val();
    var t0 = performance.now();
    Module.ccall('lela_parse', 'void', ['string'], [text]);
    var t1 = performance.now();
    console.log("Parsing and reasoning took "+ Math.round(t1 - t0) +" milliseconds");
    scrollToBottom($('#parse-output'));
}

function resultClass(r) { return r ? 'success' : 'failure'; }
function resultLabel(r) { return r ? 'Success' : 'Failure'; }

function announceEntailment(k, phi, success) {
    //alert("Entails ("+ k +", "+ phi +") = "+ success);
    $('#parse-output').append(
        '<li class="announcement entailment '+ resultClass(success)+'">'+
        '<div class="split-level">'+ k +'</div><div class="formula">'+ phi +'</div><div class="result"></div>'+
        '</li>');
}

function announceConsistency(k, phi, success) {
    //alert("Consistent ("+ k +", "+ phi +") = "+ success);
    $('#parse-output').append(
        '<li class="announcement consistency '+ resultClass(success)+'">'+
        '<div class="split-level">'+ k +'</div><div class="formula">'+ phi +'</div><div class="result"></div>'+
        '</li>');
}

function announceResult(success, msg) {
    //alert("Success = "+ success +", msg = "+ msg);
    $('#parse-output').append(
        '<li class="announcement overall '+ resultClass(success)+'">'+
        '<div class="parser-result">Parser end result: '+ resultLabel(success) +' ('+ msg +')</div>'+
        '</li>');
}

function redirectConsole() {
    if (typeof console  != "undefined") {
        if (typeof console.log != 'undefined') {
            console.olog = console.log;
        } else {
            console.olog = function() {};
        }
    }
    console.log = function(message) {
        console.olog(message);
        if (message.length == 0) {
            return;
        }
        if (typeof message.charCodeAt !== 'undefined') {
            var c = message.charCodeAt(0);
            if ((65 <= c && c <= 90) || (97 <= c && c <= 122) || $('#debug-output').last() == null) {
                $('#debug-output').append('<li>'+ message +'</li>');
            } else {
                $('#debug-output').children().last().append('<br />'+ message);
            }
        }
    };
    console.error = console.debug = console.info = console.log;
}
</script>



<h2>Reasoning Results</h2>

<p>
Click the button above to let the reasoner do its work. It should report the results of the queries below.
Note that the reasoner brings the query formulas into a normal form (similar to negation normal form), so the printed formulas below may differ syntactically from your queries.
</p>

<ul id="parse-output">
</ul>

<p><a href="#debug-toggle" id="debug-toggle">Click here</a> to display/hide debug output.</p>


<div id="debug-div" style="display: none;">
<h3>Debug Output</h3>

<p>The Javascript console output is displayed below.</p>

<ul id="debug-output">
</ul>
</div>



<h2>About the Reasoner</h2>

<p>
The logical language features functions and equality, first-order quantification, standard names, and sorts.
(Predicates are not built-in but can be simulated with no overhead using boolean functions.)
Knowledge bases are restricted to be in clausal form with only universally quantified variables &ndash; these KBs are called proper<sup>+</sup>.
(Existentially quantified variables in the knowledge base can be simulated with functions.)
Queries are not subject to any syntactic restriction.
</p>

<p>
Decision procedures for sound entailment [KR-2016] and sound consistency [ECAI-2016] are implemented.
Future work are the conditional beliefs [ECAI-2016] (should be easy), actions [KR-2014] [ (as a preprocessing step), and introspection [IJCAI-2013].
</p>

<p>
The reasoner is written in C++.
The code is available at <a href="https://www.github.com/schwering/lela">github.com/schwering/lela</a>.
This demo is compiled by <a href="http://emscripten.org">emscripten</a>, which compiles C++ to Javascript.
On my computer, the Javascript is 1.5&times; to 5&times; slower than the native binary.
</p>

<p>
Please report bugs to <a href="mailto:c.schwering@unsw.edu.au">c.schwering@unsw.edu.au</a>.
</p>



<h2 id="syntax">The Problem Description Language</h2>

<p>A problem description consists of four parts:</p>
<ol>
    <li> declarations of sorts, variables, standard names, and functions; </li>
    <li> the knowledge definition; </li>
    <li> optional abbreviations for formulas; </li>
    <li> entailment and/or consistency queries. </li>
</ol>
<p>
The syntax of these segments is as follows, where <span class="code">this font</span> is a word the problem description language, and <span class="metavariable">this font</span> represents a meta-variable.
</p>

<p>
All sorts, variables, names, and function symbols must be declared before they are used.
They are of the following form:
</p>
<ul class="grammar">
    <li><span class="code">Sort <span class="metavariable">sort-id</span>;</span>
    <li><span class="code">Variable <span class="metavariable">id</span> -&gt; <span class="metavariable">sort-id</span>;</span> &nbsp;&nbsp;or&nbsp;&nbsp;
        <span class="code">Var <span class="metavariable">id</span> -&gt; <span class="metavariable">sort-id</span>;</span></li>
    <li><span class="code">Name <span class="metavariable">id</span> -&gt; <span class="metavariable">sort-id</span>;</span></li>
    <li><span class="code">Function <span class="metavariable">id</span>/<span class="metavariable">arity</span> -&gt; <span class="metavariable">sort-id</span>;</span> &nbsp;&nbsp;or&nbsp;&nbsp;
        <span class="code">Fun <span class="metavariable">id</span>/<span class="metavariable">arity</span> -&gt; <span class="metavariable">sort-id</span>;</span></li>
</ul>
<p>
where <span class="metavariable">sort-id</span> and <span class="metavariable">id</span> are identifiers and <span class="metavariable">arity</span> &ge; 0 is a number.
Sort identifiers must be declared before they are used in variable, name, or function declarations.
Sort identifiers cannot be declared twice.
Variable, name, and function identifiers cannot be declared twice.
An identifier starts with a lower- or upper-case letter and may be followed by further letters, digits, or underscore symbols.
</p>

<p>
The knowledge base consists of a sequence of clauses, each of which is written as
</p>
<ul class="grammar">
    <li><span class="code">KB&nbsp;(<span class="metavariable">literal<sub>1</sub></span> || <span class="metavariable">...</span> || <span class="metavariable">literal<sub>k</sub></span>);</span>
        &nbsp;&nbsp;or&nbsp;&nbsp;
       <span class="code">KB&nbsp;(<span class="metavariable">literal<sub>1</sub></span> v <span class="metavariable">...</span> v <span class="metavariable">literal<sub>k</sub></span>);</span></li>
</ul>
<p>
where <span class="metavariable">literal<sub>i</sub></span> denotes a literal, which either an equality or an inequality expression:
</p>
<ul class="grammar">
    <li><span class="code"><span class="metavariable">t<sub>1</sub></span> == <span class="metavariable">t<sub>2</sub></span></span> &nbsp;&nbsp;or&nbsp;&nbsp;
        <span class="code"><span class="metavariable">t<sub>1</sub></span> = <span class="metavariable">t<sub>2</sub></span></span></li>
    <li><span class="code"><span class="metavariable">t<sub>1</sub></span> != <span class="metavariable">t<sub>2</sub></span></span> &nbsp;&nbsp;or&nbsp;&nbsp;
        <span class="code"><span class="metavariable">t<sub>1</sub></span> /= <span class="metavariable">t<sub>2</sub></span></span></li>
</ul>
<p>
where <span class="metavariable">t<sub>i</sub></span> is a term.
A term is either the identifier of a previously declared variable, a standard name, or a function symbol <span class="metavariable">f</span> applied to other terms <span class="metavariable">t'<sub>i</sub></span>, written <span class="code"><span class="metavariable">f</span>(<span class="metavariable">t'<sub>1</sub></span>, <span class="metavariable">...</span>, <span class="metavariable">t'<sub>k</sub></span>)</span>.
When <span class="metavariable">f</span> is a constant symbol (that is, has arity 0), the brackets may be omitted.
Variables in the KB are implicitly universally quantified.
</p>

<p>
For convenience, abbreviations for formulas can be defined by
</p>
<ul class="grammar">
    <li><span class="code">Let <span class="metavariable">id</span> := <span class="metavariable">formula</span>;</span></li>
</ul>
<p>
where <span class="metavariable">id</span> is the identifier by which the formula can later be referred.
Formula identifiers can be redefined.
</p>

<p>
The set of formulas includes literals as defined above as well as negated formulas, disjunctions, conjunctions, and existentially and universally quantified formulas, formulas in brackets, and abbreviations:
<ul class="grammar">
    <li><span class="code">!<span class="metavariable">formula</span></span> &nbsp;&nbsp;or&nbsp;&nbsp;
        <span class="code">~<span class="metavariable">formula</span></span></li>
    <li><span class="code"><span class="metavariable">formula<sub>1</sub></span> &amp;&amp; <span class="metavariable">formula<sub>2</sub></span></span> &nbsp;&nbsp;or&nbsp;&nbsp;
        <span class="code"><span class="metavariable">formula<sub>1</sub></span> ^ <span class="metavariable">formula<sub>2</sub></span></span></li>
    <li><span class="code"><span class="metavariable">formula<sub>1</sub></span> || <span class="metavariable">formula<sub>2</sub></span></span> &nbsp;&nbsp;or&nbsp;&nbsp;
        <span class="code"><span class="metavariable">formula<sub>1</sub></span> v <span class="metavariable">formula<sub>2</sub></span></span></li>
    <li><span class="code">Ex <span class="metavariable">x</span> <span class="metavariable">formula</span></span></li>
    <li><span class="code">Fa <span class="metavariable">x</span> <span class="metavariable">formula</span></span></li>
    <li><span class="code">(<span class="metavariable">formula</span>)</span></li>
    <li><span class="code"><span class="metavariable">formula-identifier</span></span></li>
</ul>
<p>
where <span class="metavariable">x</span> is the identifier of a previously declared variable and <span class="metavariable">formula-identifier</span> has been introduced in a formula abbreviation.
Conjunction binds stronger than disjunction, and the scope of negation and quantifiers is minimal.
</p>

<p>
Formulas can be used to query for entailment or consistency:
</p>
<ul class="grammar">
    <li><span class="code">Entails&nbsp;(<span class="metavariable">k</span>, <span class="metavariable">formula</span>);</span></li>
    <li><span class="code">Consistent&nbsp;(<span class="metavariable">k</span>, <span class="metavariable">formula</span>);</span></li>
</ul>
<p>
where <span class="metavariable">k</span> &ge; 0 is a natural number that denotes the reasoning effort and <span class="metavariable">formula</span> is a formula as defined above.
Both entailment and consistency queries are sound but incomplete with respect to classical logic.
The reasoning effort is measured in case splits (a split means to select a term <span class="code">f(n<sub>1</sub>,...,n<sub>l</sub>)</span> and consider all possible denotations of that term) in entailment queries, and as term assignments (an assignment means to select a term <span class="code">f(t<sub>1</sub>,...,t<sub>l</sub>)</span> and fix their denotation) in consistency queries.
</p>
<p>
For automated testing, it is also desirable to augment queries with the respected result.
The language supports assertions and refutations for that purpose:
</p>
<ul class="grammar">
    <li><span class="code">Assert Entails&nbsp;(<span class="metavariable">k</span>, <span class="metavariable">formula</span>);</span></li>
    <li><span class="code">Refute Entails&nbsp;(<span class="metavariable">k</span>, <span class="metavariable">formula</span>);</span></li>
    <li><span class="code">Assert Consistent&nbsp;(<span class="metavariable">k</span>, <span class="metavariable">formula</span>);</span></li>
    <li><span class="code">Refute Consistent&nbsp;(<span class="metavariable">k</span>, <span class="metavariable">formula</span>);</span></li>
</ul>
<p>
Execution aborts with an asserted entailment/consistency does not hold or when a refuted entailment/consistency does hold.
</p>

<p>
C-style single line comments are supported as well: 
    <span class="code">//&nbsp;<span class="metavariable">rest of line is comment</span>.
</p>

<h2>References</h2>
<ul>
    <li>
        Lakemeyer and Levesque. Decidable Reasoning in a Logic of Limited Belief with Function Symbols. KR 2016.
        <a href="https://kbsg.rwth-aachen.de/sites/kbsg/files/LakemeyerLevesque2016.pdf">PDF</a></li>
    <li>
        Schwering and Lakemeyer. Decidable Reasoning in a First-Order Logic of Limited Conditional Belief. ECAI 2016.
        <a href="https://kbsg.rwth-aachen.de/sites/kbsg/files/SchweringLakemeyer2016.pdf">PDF</a>
    </li>
    <li>
        Lakemeyer and Levesque. Decidable Reasoning in a Fragment of the Epistemic Situation Calculus. KR 2014.
        <a href="https://pdfs.semanticscholar.org/8ac9/a2955895cd391ec2b62d8210ee8206979f4a.pdf">PDF</a>
    </li>
    <li>
        Lakemeyer and Levesque. Decidable Reasoning in a Logic of Limited Belief with Introspection and Unknown Individuals. IJCAI 2013.
        <a href="https://pdfs.semanticscholar.org/387c/951016c68aaf8ce36bb87e5ea4d1ef42405d.pdf">PDF</a>
    </li>
</ul>

</body>
</html>

