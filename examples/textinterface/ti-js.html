<!DOCTYPE HTML>
<!-- vim:filetype=html:textwidth=200:shiftwidth=4:softtabstop=4:expandtab
-->
<html lang="en">
<head>
    <meta charset="UTF-8"> 
    <title>Limited reasoner demo</title>

    <link href="//fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
    <style type="text/css">
        body { font-family: 'Open Sans', sans-serif; font-size: 140%; }
        p { text-align: justify; }
        i { font-weight: 600; font-style: normal; }

        h1       { font-size: 220%; }
        h2       { font-size: 170%; border-bottom: 1px solid #aaa; }

        #examples { font-family: inherit; font-weight: bold; font-size: inherit; }
        #parse-text { background-color: #eeeeee; font-family: monospace; font-size: 140%; border: 2px solid black; width: 95%; height: 70%; }
        #parse-text { background: repeating-linear-gradient( -45deg, #e5e5e5, #e5e5e5 10px, #eeeeee 10px, #eeeeee 20px); }
        #parse-button { font-family: inherit; font-weight: bold; font-size: inherit; }
        #parse-button {
            color: #eee;
            background:
                linear-gradient(27deg, #151515 5px, transparent 5px) 0 5px,
                linear-gradient(207deg, #151515 5px, transparent 5px) 10px 0px,
                linear-gradient(27deg, #222 5px, transparent 5px) 0px 10px,
                linear-gradient(207deg, #222 5px, transparent 5px) 10px 5px,
                linear-gradient(90deg, #1b1b1b 10px, transparent 10px),
                linear-gradient(#1d1d1d 25%, #1a1a1a 25%, #1a1a1a 50%, transparent 50%, transparent 75%, #242424 75%, #242424);
            background-color: #131313;
            background-size: 20px 20px;
        }
        #parse-button { display: block; margin-top: 2ex; margin-left: 25%; min-width: 25%; padding-top: 3ex; padding-bottom: 3ex; }

        #parse-output, #debug-output { width: 95%; min-height: 5ex; background-color: #dddddd; border: 2px solid black; }
        #parse-output, #debug-output { background: repeating-linear-gradient( 45deg, #e5e5e5, #e5e5e5 10px, #eeeeee 10px, #eeeeee 20px); }

        #parse-output { font-family: monospace; font-size: 140%; }
        #debug-output { font-family: monospace; font-size: 110%; }

        .announcement { font-family: font-family: monospace; font-weight: bold; white-space: pre-wrap; }
        .announcement div { display: inline-block; }
        .announcement .parse-result,
        .announcement.failure .parse-remainder { display: block; }
        .announcement.success .parse-remainder { display: none; }

        .announcement .split-level,
        .announcement .formula,
        .announcement .parse-result,
        .announcement .parse-remainder { color: black; font-weight: normal; }

        .announcement .split-level::after,
        .announcement .split-level::before,
        .announcement .formula::after,
        .announcement .formula::before,
        .announcement .parse-result::after,
        .announcement .parse-result::before,
        .announcement .parse-remainder::after,
        .announcement .parse-remainder::before { font-weight: bold; }

        .announcement.success *::after, .announcement.success *::before { color: green; }
        .announcement.failure *::after, .announcement.failure *::before { color: red; }

        .announcement.query .formula::before { content: "Query: "; }
        .announcement.query .formula::after { content: "  \2192  " }

        .announcement.success .result::after { content: "success" }
        .announcement.failure .result::after { content: "failure" }

        .announcement.overall.success .parse-result::before { display: block; content: "Success"; }
        .announcement.overall.failure .parse-result::before { display: block; content: "Failure"; }
        .announcement.overall.failure .parse-remainder::before { display: block; content: "with remaining input"; }

        ul.grammar { list-style-type: none; }
        .code { font-family: monospace; font-weight: bold; }
        .metavariable { font-family: monospace; font-weight: normal; color: #800080; }
    </style>

    <script src="jquery-3.1.1.min.js"></script>
    <script src="ti-js.js"></script>
</head>

<body>

<h1>Limited Reasoner Demo: Text Interface</h1>

<p>
<b>Quick start:</b> have a look at the "Problem Description", hit the "Click me!" button, and check the output under "Reasoning Results".
</p>

<p>
Also have a look at the <a href="../minesweeper/" target="_blank">the other demo: minesweeper</a>.
</p>

<h2>Problem Description</h2>

<p>
Load an example:
<select id="examples">
<option id="example-sonny" value="example-father-of-sonny.txt">Example: Unknown Father</option>
<option id="example-siblings" value="example-siblings.txt">Example: Siblings</option>
<option id="example-veggie" value="example-veggie.txt">Example: Veggie</option>
<option id="example-propositions" value="test-propositions.txt">Test: Propositions</option>
<option id="example-functions" value="test-functions.txt">Test: Constants</option>
<option id="example-none" value="" style="color: #666;">none</option>
</select> <br />
If you like, you can edit the text. For help on the syntax, see <a href="#syntax">below</a>.
</p>

<textarea id="parse-text" cols="80" rows="20">
</textarea>

<input value="Click me!" type="button" id="parse-button" />

<script>
$(document).ready(function() {
   redirectConsole();

    $('#debug-toggle').click(function(){ $('#debug-div').toggle(); return false; });
    
    var select_ex = getParameterByName('ex');
    if (select_ex) {
        select_ex = 'example-' + select_ex;
        $('#examples option').filter(function(){
            return this.id === select_ex
        }).prop('selected', true);
    }

    $('#examples').change(function() {
        var file = null;
        $('#examples option:selected').each(function() { file = $(this).val(); });
        if (file) {
            $.ajax({
                url : file,
                dataType: 'text',
                success: function(data) {
                    $('#parse-text').val(data.trim());
                    scrollToBottom($('#parse-button'));
                    $('#parse-button').focus();
                }
            });
        } else {
            $('#parse-text').val("").focus();
        }
    }).change();

    $('#parse-button').click(function() {
        parse();
    });
});

function getParameterByName(name) {
    var url = window.location.href;
    name = name.replace(/[\[\]]/g, "\\$&");
    var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
        results = regex.exec(url);
    if (!results) return null;
    if (!results[2]) return '';
    return decodeURIComponent(results[2].replace(/\+/g, " "));
}

function scrollToBottom(e) {
    var wHeight = $(window).height();
    var eOffset = $(e).offset().top;
    var eHeight = $(e).outerHeight();
    $('html, body').animate({ scrollTop: eOffset - wHeight + eHeight }, 200);
}

function parse() {
    $('#parse-output').empty();
    $('#debug-output').empty();
    var text = $('#parse-text').val();
    var t0 = performance.now();
    Module.ccall('lela_parse', 'void', ['string'], [text]);
    var t1 = performance.now();
    console.log("Parsing and reasoning took "+ Math.round(t1 - t0) +" milliseconds");
    scrollToBottom($('#parse-output'));
}

function resultClass(r) { return r ? 'success' : 'failure'; }
function resultLabel(r) { return r ? 'Success' : 'Failure'; }

function announceQuery(phi, success) {
    $('#parse-output').append(
        '<li class="announcement query '+ resultClass(success)+'">'+
        '<div class="formula">'+ phi +'</div><div class="result"></div>'+
        '</li>');
}

function announceResult(success, msg, remainder) {
    $('#parse-output').append(
        '<li class="announcement overall '+ resultClass(success)+'">'+
        '<div class="parse-result">'+ msg +'</div>'+
        '<div class="parse-remainder">'+ remainder +'</div>'+
        '</li>');
}

function redirectConsole() {
    if (typeof console  != "undefined") {
        if (typeof console.log != 'undefined') {
            console.olog = console.log;
        } else {
            console.olog = function() {};
        }
    }
    console.log = function(message) {
        console.olog(message);
        if (message.length == 0) {
            return;
        }
        if (typeof message.charCodeAt !== 'undefined') {
            var c = message.charCodeAt(0);
            if ((65 <= c && c <= 90) || (97 <= c && c <= 122) || $('#debug-output').last() == null) {
                $('#debug-output').append('<li>'+ message +'</li>');
            } else {
                $('#debug-output').children().last().append('<br />'+ message);
            }
        }
    };
    console.error = console.debug = console.info = console.log;
}
</script>



<h2>Reasoning Results</h2>

<p>
Click the button above to let the reasoner do its work. It should report the results of the queries below.
Note that the reasoner brings the query formulas into a normal form (similar to negation normal form), so the printed formulas below may differ syntactically from your queries.
</p>

<ul id="parse-output">
</ul>

<p><a href="#debug-toggle" id="debug-toggle">Click here</a> to display/hide debug output.</p>


<div id="debug-div" style="display: none;">
<h3>Debug Output</h3>

<p>The Javascript console output is displayed below.</p>

<ul id="debug-output">
</ul>
</div>



<h2>About the Reasoner</h2>

<p>
The logical language features functions and equality, first-order quantification, standard names, and sorts.
(Predicates are not built-in but can be simulated with no overhead using boolean functions.)
Knowledge bases are restricted to be in clausal form with only universally quantified variables &ndash; these KBs are called proper<sup>+</sup>.
(Existentially quantified variables in the knowledge base can be simulated with functions.)
Queries are not subject to any syntactic restriction.
</p>

<p>
Decision procedures for sound entailment [KR-2016] and sound consistency [ECAI-2016] are implemented.
Future work are the conditional beliefs [ECAI-2016] (should be easy), actions [KR-2014] [ (as a preprocessing step), and introspection [IJCAI-2013].
</p>

<p>
The reasoner is written in C++.
The code is available at <a href="https://www.github.com/schwering/lela">github.com/schwering/lela</a>.
This demo is compiled by <a href="http://emscripten.org">emscripten</a>, which translates C++ to Javascript.
On my computer, the Javascript is 1.5&times; to 5&times; slower than the native binary.
</p>

<p>
Please report bugs to <a href="mailto:c.schwering@unsw.edu.au">c.schwering@unsw.edu.au</a>.
</p>



<h2 id="syntax">The Problem Description Language</h2>

<p>A problem description consists of four parts:</p>
<ol>
    <li> declarations of sorts, variables, standard names, and functions; </li>
    <li> optional abbreviations for formulas; </li>
    <li> the knowledge definition; </li>
    <li> entailment and/or consistency queries. </li>
</ol>
<p>
The syntax of these segments is as follows, where <span class="code">this font</span> is a word the problem description language, and <span class="metavariable">this font</span> represents a meta-variable.
</p>

<p>
All sorts, variables, names, and function symbols must be declared before they are used.
They are of the following form:
</p>
<ul class="grammar">
    <li><span class="code">Sort <span class="metavariable">sort</span>;</span>
    <li><span class="code">Variable <span class="metavariable">x</span> -&gt; <span class="metavariable">sort</span>;</span> &nbsp;&nbsp;or&nbsp;&nbsp;
        <span class="code">Var <span class="metavariable">x</span> -&gt; <span class="metavariable">sort</span>;</span></li>
    <li><span class="code">Name <span class="metavariable">n</span> -&gt; <span class="metavariable">sort</span>;</span></li>
    <li><span class="code">Function <span class="metavariable">f</span>/<span class="metavariable">arity</span> -&gt; <span class="metavariable">sort</span>;</span> &nbsp;&nbsp;or&nbsp;&nbsp;
        <span class="code">Fun <span class="metavariable">f</span>/<span class="metavariable">arity</span> -&gt; <span class="metavariable">sort</span>;</span></li>
</ul>
<p>
where <span class="metavariable">sort</span>, <span class="metavariable">x</span>, <span class="metavariable">n</span>, <span class="metavariable">f</span> are identifiers and <span class="metavariable">arity</span> is a natural number &ge; 0.
An identifier is a sequence of lower- and upper-case letters, digits, underscore and dash symbols, with the first symbol being a letter or underscore.
Sort identifiers must be declared before they are used in variable, name, or function declarations.
No two sorts can have the same identifier.
No two variables, names, or functions can have the same identifier.
</p>

<p>
The set of formulas includes literals, negated formulas, disjunctions, conjunctions, implications, equivalences, and existentially and universally quantified formulas, knowledge and non-knowledge and belief modalities, formulas in brackets, and abbreviations:
<ul class="grammar">
    <li><span class="code"><span class="metavariable">literal</span></span></li>
    <li><span class="code">!<span class="metavariable">formula</span></span> &nbsp;&nbsp;or&nbsp;&nbsp;
        <span class="code">~<span class="metavariable">formula</span></span></li>
    <li><span class="code"><span class="metavariable">formula<sub>1</sub></span> &amp;&amp; <span class="metavariable">formula<sub>2</sub></span></span> &nbsp;&nbsp;or&nbsp;&nbsp;
        <span class="code"><span class="metavariable">formula<sub>1</sub></span> &amp; <span class="metavariable">formula<sub>2</sub></span></span> &nbsp;&nbsp;or&nbsp;&nbsp;
        <span class="code"><span class="metavariable">formula<sub>1</sub></span> ^ <span class="metavariable">formula<sub>2</sub></span></span></li>
    <li><span class="code"><span class="metavariable">formula<sub>1</sub></span> || <span class="metavariable">formula<sub>2</sub></span></span> &nbsp;&nbsp;or&nbsp;&nbsp;
        <span class="code"><span class="metavariable">formula<sub>1</sub></span> | <span class="metavariable">formula<sub>2</sub></span></span> &nbsp;&nbsp;or&nbsp;&nbsp;
        <span class="code"><span class="metavariable">formula<sub>1</sub></span> v <span class="metavariable">formula<sub>2</sub></span></span></li>
    <li><span class="code"><span class="metavariable">formula<sub>1</sub></span> -&gt; <span class="metavariable">formula<sub>2</sub></span></span></li>
    <li><span class="code"><span class="metavariable">formula<sub>1</sub></span> &lt;-&gt; <span class="metavariable">formula<sub>2</sub></span></span></li>
    <li><span class="code">Ex <span class="metavariable">x</span> <span class="metavariable">formula</span></span></li>
    <li><span class="code">Fa <span class="metavariable">x</span> <span class="metavariable">formula</span></span></li>
    <li><span class="code">Know&lt;<span class="metavariable">split-level</span>&gt; <span class="metavariable">formula</span></span></li>
    <li><span class="code">Cons&lt;<span class="metavariable">split-level</span>&gt; <span class="metavariable">formula</span></span></li>
    <li><span class="code">Bel&lt;<span class="metavariable">split-level<sub>1</sub></span>,<span class="metavariable">split-level<sub>2</sub></span>&gt; <span class="metavariable">formula<sub>1</sub></span> ==&gt; <span class="metavariable">formula<sub>2</sub></span></span></li>
    <li><span class="code">(<span class="metavariable">formula</span>)</span></li>
    <li><span class="code"><span class="metavariable">formula-id</span></span></li>
</ul>
<p>
Here <span class="metavariable">literal</span> denotes a literal, which either an equality or an inequality expression:
</p>
<ul class="grammar">
    <li><span class="code"><span class="metavariable">t<sub>1</sub></span> == <span class="metavariable">t<sub>2</sub></span></span> &nbsp;&nbsp;or&nbsp;&nbsp;
        <span class="code"><span class="metavariable">t<sub>1</sub></span> = <span class="metavariable">t<sub>2</sub></span></span></li>
    <li><span class="code"><span class="metavariable">t<sub>1</sub></span> != <span class="metavariable">t<sub>2</sub></span></span> &nbsp;&nbsp;or&nbsp;&nbsp;
        <span class="code"><span class="metavariable">t<sub>1</sub></span> /= <span class="metavariable">t<sub>2</sub></span></span></li>
</ul>
<p>
where <span class="metavariable">t<sub>i</sub></span> is a term.
A term is either the identifier of a previously declared variable <span class="metavariable">x</span>, a standard name <span class="metavariable">n</span>, or a compound term <span class="code"><span class="metavariable">f</span>(<span class="metavariable">t'<sub>1</sub></span>, <span class="metavariable">...</span>, <span class="metavariable">t'<sub>k</sub></span>)</span> where a function
symbol <span class="metavariable">f</span> is applied to other terms <span class="metavariable">t'<sub>i</sub></span>.
When <span class="metavariable">f</span> is a constant symbol (that is, has arity 0), the brackets may be omitted.
Variables in the KB are implicitly universally quantified.
</p>
<p>
The <span class="metavariable">split-level</span> is a natural number &ge; 0 that indicates how much reasoning effort the reasoner can spend on proving the <span class="metavariable">formula</span> in the modality.
The modal operator <span class="code">Know</span> is the usual knowledge modality, <span class="code">Cons</span> means a formula is considered possible (that is, its negation is not known), and <span class="code">Bel</span> is conditional belief.
All three operators are sound but incomplete with respect to the unlimited logic of only-knowing/believing.
The <span class="metavariable">split-level</span> can have two different meanings.
The one within <span class="code">Know</span> and the first parameter of <span class="code">Bel</span> specify how many terms may be split.
A split means to select a term <span class="code">f(n<sub>1</sub>,...,n<sub>l</sub>)</span> and consider all possible denotations of that term; that is, the reasoner tests all (relevant) assignments for these terms.
The <span class="metavariable">split-level</span> in <span class="code">Cons</span> and the second parameter of <span class="code">Bel</span>, on the other hand, specify how many terms can be freely assigned a value, which means to select a (possibly non-ground) term <span class="code">f(t<sub>1</sub>,...,t<sub>l</sub>)</span> and fix its denotation.
</p>
<p>
The identifiers of any variables <span class="metavariable">x</span>, standard names standard name <span class="metavariable">n</span>, function symbols <span class="metavariable">f</span>, or formula abbreviations <span class="metavariable">formula-id</span> must have been declared before they can be used in formulas.
</p>
<p>
Equivalence binds stronger than implication, implication binds stronger than conjunction, conjunction binds stronger than disjunction, and the scope of negation, quantifiers, and modal operators is minimal.
Let me emphasize the last point.
For example, to say that <span class="code"><span class="metavariable">formula<sub>1</sub></span> || <span class="metavariable">formula<sub>2</sub></span></span> is known, you need to brackets as in <span class="code">Know&lt;<span class="metavariable">split-level</span>&gt; (<span class="metavariable">formula<sub>1</sub></span> || <span class="metavariable">formula<sub>2</sub></span>)</span>.
</p>

<p>
Any formula abbreviation <span class="metavariable">formula-id</span> must be defined before use:
</p>
<ul class="grammar">
    <li><span class="code">Let <span class="metavariable">formula-id</span> := <span class="metavariable">formula</span>;</span></li>
</ul>
<p>
where <span class="metavariable">formula-id</span> is the identifier by which the formula can later be referred.
The same identifier can be used for two different formulas; the semantics is that the latter definition overrides the former.
</p>

<p>
The knowledge base consists of a sequence of clauses, each of which is written (synonymously) as
</p>
<ul class="grammar">
    <li><span class="code">KB:&nbsp;<span class="metavariable">formula</span>;</span></li>
</ul>
<p>
with the syntactic restriction that the <i>normal form</i> (explained below) of <span class="metavariable">formula</span> is a clause with leading universal quantifier, or a clause within a knowledge modality <span class="code">Know&lt;<span class="metavariable">split-level</span>&gt; <span class="metavariable">formula</span></span> (the <span class="metavariable">split-level</span> is ignored then), or a formula <span class="code">Bel&lt;<span class="metavariable">split-level<sub>1</sub></span>,<span class="metavariable">split-level<sub>2</sub></span>&gt; <span class="metavariable">formula<sub>1</sub></span> ==&gt; <span class="metavariable">formula<sub>2</sub></span></span> where the normal form of <span class="code">!<span class="metavariable">formula<sub>1</sub></span> || <span class="metavariable">formula<sub>2</sub></span></span> must be universally quantified clause and the <span class="metavariable">split-level</span>s affect how faithful the induced system of spheres is to the unlimited logic.
</p>

<p>
Free variables in <span class="metavariable">formula</span> in KB definitions are implicitly universally quantified.
The definition of the normal form is tedious, but the idea is this: push negations inwards but not into clauses, and pull quantifiers out of clauses.
The rationale is to create new clauses (while avoiding the exponential blowup of a full CNF).
Additionally, terms are flattened so that no two function symbols occur in a any literal.
For instance, a disjunction <span class="code">KB:&nbsp;(<span class="metavariable">literal<sub>1</sub></span> || <span class="metavariable">...</span> || <span class="metavariable">literal<sub>k</sub></span>);</span> meets this requirement trivially.
Implications are also allowed, provided that the negation of the antecedent as well as the consequent meet above form, as does <span class="code">KB:&nbsp;(Ex <span class="metavariable">x</span> (<span class="metavariable">literal<sub>1</sub></span> &amp;&amp; <span class="metavariable">literal<sub>k</sub></span>) -&gt; (<span class="metavariable">literal<sub>1</sub></span> || <span class="metavariable">literal<sub>k</sub></span>));</span>.
</p>

<p>
</p>

<p>
Queries can be of the form
For automated testing, the language supports assertions and refutations:
</p>
<ul class="grammar">
    <li><span class="code">Query: <span class="metavariable">formula</span>;</span></li>
    <li><span class="code">Assert: <span class="metavariable">formula</span>;</span></li>
    <li><span class="code">Refute: <span class="metavariable">formula</span>;</span></li>
</ul>
<p>
The query <span class="metavariable">formula</span> must be subjective, which means terms must not occur outside of modal operators.
The <span class="code">Assert</span> and <span class="code">Refute</span> versions just differ from the <span class="code">Query</span> version in that they yield a error when the query does not come out true or false, respectively.
</p>

<p>
C-style single line comments are supported as well: 
    <span class="code">//&nbsp;<span class="metavariable">rest of line is comment</span></span>.
</p>

<h2>References</h2>
<ul>
    <li>
        Lakemeyer and Levesque. Decidable Reasoning in a Logic of Limited Belief with Function Symbols. KR 2016.
        <a href="https://kbsg.rwth-aachen.de/sites/kbsg/files/LakemeyerLevesque2016.pdf">PDF</a></li>
    <li>
        Schwering and Lakemeyer. Decidable Reasoning in a First-Order Logic of Limited Conditional Belief. ECAI 2016.
        <a href="https://kbsg.rwth-aachen.de/sites/kbsg/files/SchweringLakemeyer2016.pdf">PDF</a>
    </li>
    <li>
        Lakemeyer and Levesque. Decidable Reasoning in a Fragment of the Epistemic Situation Calculus. KR 2014.
        <a href="https://pdfs.semanticscholar.org/8ac9/a2955895cd391ec2b62d8210ee8206979f4a.pdf">PDF</a>
    </li>
    <li>
        Lakemeyer and Levesque. Decidable Reasoning in a Logic of Limited Belief with Introspection and Unknown Individuals. IJCAI 2013.
        <a href="https://pdfs.semanticscholar.org/387c/951016c68aaf8ce36bb87e5ea4d1ef42405d.pdf">PDF</a>
    </li>
</ul>

</body>
</html>

