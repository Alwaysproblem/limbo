<!DOCTYPE HTML>
<!-- vim:filetype=html:textwidth=200:shiftwidth=4:softtabstop=4:expandtab
-->
<html lang="en">
<head>
    <meta charset="UTF-8"> 
    <title>Limited reasoner demo</title>

    <link href="//fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
    <style type="text/css">
        body { font-family: 'Open Sans', sans-serif; font-size: 140%; }
        p { text-align: justify; }
        i { font-weight: 600; font-style: normal; }

        h1       { font-size: 220%; }
        h2       { font-size: 170%; border-bottom: 1px solid #aaa; }

        #examples { font-family: inherit; font-weight: bold; font-size: inherit; }
        #parse-text { background-color: #eeeeee; font-family: monospace; font-size: 140%; border: 2px solid black; width: 95%; height: 70%; }
        #parse-text { background: repeating-linear-gradient( -45deg, #e5e5e5, #e5e5e5 10px, #eeeeee 10px, #eeeeee 20px); }
        #parse-button { font-family: inherit; font-weight: bold; font-size: inherit; }
        #parse-button {
            color: #eee;
            background:
                linear-gradient(27deg, #151515 5px, transparent 5px) 0 5px,
                linear-gradient(207deg, #151515 5px, transparent 5px) 10px 0px,
                linear-gradient(27deg, #222 5px, transparent 5px) 0px 10px,
                linear-gradient(207deg, #222 5px, transparent 5px) 10px 5px,
                linear-gradient(90deg, #1b1b1b 10px, transparent 10px),
                linear-gradient(#1d1d1d 25%, #1a1a1a 25%, #1a1a1a 50%, transparent 50%, transparent 75%, #242424 75%, #242424);
            background-color: #131313;
            background-size: 20px 20px;
        }
        #parse-button { display: block; margin-top: 2ex; margin-left: 25%; min-width: 25%; padding-top: 3ex; padding-bottom: 3ex; }

        #parse-output, #debug-output { width: 95%; min-height: 5ex; background-color: #dddddd; border: 2px solid black; }
        #parse-output, #debug-output { background: repeating-linear-gradient( 45deg, #e5e5e5, #e5e5e5 10px, #eeeeee 10px, #eeeeee 20px); }

        #parse-output { font-family: monospace; font-size: 140%; }
        #debug-output { font-family: monospace; font-size: 110%; }

        .announcement { font-family: font-family: monospace; font-weight: bold; white-space: pre-wrap; }
        .announcement div { display: inline-block; }

        .announcement .split-level,
        .announcement .formula { color: black; font-weight: normal; }

        .announcement .split-level::after,
        .announcement .split-level::before,
        .announcement .formula::after,
        .announcement .formula::before { font-weight: bold; }

        .announcement.success *::after, .announcement.success *::before, .announcement.success.overall * { color: green; }
        .announcement.failure *::after, .announcement.failure *::before, .announcement.failure.overall * { color: red; }

        .announcement.entailment  .split-level::before { content: "Entails    (" }
        .announcement.consistency .split-level::before { content: "Consistent (" }

        .announcement .split-level::after { content: ", " }
        .announcement .result::before { content: ")  \2192  " }

        .announcement.success .result::after { content: "success" }
        .announcement.failure .result::after { content: "failure" }

        ul.grammar { list-style-type: none; }
        .code { font-family: monospace; font-weight: bold; }
        .metavariable { font-family: monospace; font-weight: normal; color: #800080; }
    </style>

    <script src="jquery-3.1.1.min.js"></script>
    <script src="ti-js.js"></script>
</head>

<body>

<h1>Limited Reasoner Demo: Text Interface</h1>

<p>
<b>Quick start:</b> have a look at the "Problem Description", hit the "Click me!" button, and check the output under "Reasoning Results".
</p>

<p>
Also have a look at the <a href="../minesweeper/" target="_blank">the other demo: minesweeper</a>.
</p>

<h2>Problem Description</h2>

<p>
Load an example:
<select id="examples">
<option value="example-father-of-sonny.txt">Example: Unknown Father<!-- (fictitious edition)</option>
<option value="example-father-of-ronan.txt">Example: Unknown Father (Gossip edition)</option>
<option value="example-mother-of-dionysos.txt">Example: Unknown Father (Dionysos edition)</option>
<option value="example-father-of-jesus.txt">Example: Unknown Father (Jesus edition)--></option>
<option value="example-siblings.txt">Example: Siblings</option>
<option value="test-propositions-1.txt">Test: Propositions</option>
<option value="test-functions-1.txt">Test: Constants</option>
<option value="">none</option>
</select> <br />
If you like, you can edit the text. For help on the syntax, see <a href="#syntax">below</a>.
</p>

<textarea id="parse-text" cols="80" rows="20">
</textarea>

<input value="Click me!" type="button" id="parse-button" />

<script>
$(document).ready(function() {
   redirectConsole();

    $('#debug-toggle').click(function(){ $('#debug-div').toggle(); return false; });

    $('#examples').change(function() {
        var file = null;
        $('#examples option:selected').each(function() { file = $(this).val(); });
        if (file) {
            $.ajax({
                url : file,
                dataType: 'text',
                success: function(data) {
                    $('#parse-text').val(data.trim());
                    scrollToBottom($('#parse-button'));
                    $('#parse-button').focus();
                }
            });
        } else {
            $('#parse-text').val("").focus();
        }
    }).change();

    $('#parse-button').click(function() {
        parse();
    });
});

function scrollToBottom(e) {
    var wHeight = $(window).height();
    var eOffset = $(e).offset().top;
    var eHeight = $(e).outerHeight();
    $('html, body').animate({ scrollTop: eOffset - wHeight + eHeight }, 200);
}

function parse() {
    $('#parse-output').empty();
    $('#debug-output').empty();
    var text = $('#parse-text').val();
    var t0 = performance.now();
    Module.ccall('lela_parse', 'void', ['string'], [text]);
    var t1 = performance.now();
    console.log("Parsing and reasoning took "+ Math.round(t1 - t0) +" milliseconds");
    scrollToBottom($('#parse-output'));
}

function resultClass(r) { return r ? 'success' : 'failure'; }
function resultLabel(r) { return r ? 'Success' : 'Failure'; }

function announceEntailment(k, phi, success) {
    $('#parse-output').append(
        '<li class="announcement entailment '+ resultClass(success)+'">'+
        '<div class="split-level">'+ k +'</div><div class="formula">'+ phi +'</div><div class="result"></div>'+
        '</li>');
}

function announceConsistency(k, phi, success) {
    $('#parse-output').append(
        '<li class="announcement consistency '+ resultClass(success)+'">'+
        '<div class="split-level">'+ k +'</div><div class="formula">'+ phi +'</div><div class="result"></div>'+
        '</li>');
}

function announceResult(success, msg) {
    $('#parse-output').append(
        '<li class="announcement overall '+ resultClass(success)+'">'+
        '<div class="parser-result">Parser end result: '+ resultLabel(success) +' ('+ msg +')</div>'+
        '</li>');
}

function redirectConsole() {
    if (typeof console  != "undefined") {
        if (typeof console.log != 'undefined') {
            console.olog = console.log;
        } else {
            console.olog = function() {};
        }
    }
    console.log = function(message) {
        console.olog(message);
        if (message.length == 0) {
            return;
        }
        if (typeof message.charCodeAt !== 'undefined') {
            var c = message.charCodeAt(0);
            if ((65 <= c && c <= 90) || (97 <= c && c <= 122) || $('#debug-output').last() == null) {
                $('#debug-output').append('<li>'+ message +'</li>');
            } else {
                $('#debug-output').children().last().append('<br />'+ message);
            }
        }
    };
    console.error = console.debug = console.info = console.log;
}
</script>



<h2>Reasoning Results</h2>

<p>
Click the button above to let the reasoner do its work. It should report the results of the queries below.
Note that the reasoner brings the query formulas into a normal form (similar to negation normal form), so the printed formulas below may differ syntactically from your queries.
</p>

<ul id="parse-output">
</ul>

<p><a href="#debug-toggle" id="debug-toggle">Click here</a> to display/hide debug output.</p>


<div id="debug-div" style="display: none;">
<h3>Debug Output</h3>

<p>The Javascript console output is displayed below.</p>

<ul id="debug-output">
</ul>
</div>



<h2>About the Reasoner</h2>

<p>
The logical language features functions and equality, first-order quantification, standard names, and sorts.
(Predicates are not built-in but can be simulated with no overhead using boolean functions.)
Knowledge bases are restricted to be in clausal form with only universally quantified variables &ndash; these KBs are called proper<sup>+</sup>.
(Existentially quantified variables in the knowledge base can be simulated with functions.)
Queries are not subject to any syntactic restriction.
</p>

<p>
Decision procedures for sound entailment [KR-2016] and sound consistency [ECAI-2016] are implemented.
Future work are the conditional beliefs [ECAI-2016] (should be easy), actions [KR-2014] [ (as a preprocessing step), and introspection [IJCAI-2013].
</p>

<p>
The reasoner is written in C++.
The code is available at <a href="https://www.github.com/schwering/lela">github.com/schwering/lela</a>.
This demo is compiled by <a href="http://emscripten.org">emscripten</a>, which translates C++ to Javascript.
On my computer, the Javascript is 1.5&times; to 5&times; slower than the native binary.
</p>

<p>
Please report bugs to <a href="mailto:c.schwering@unsw.edu.au">c.schwering@unsw.edu.au</a>.
</p>



<h2 id="syntax">The Problem Description Language</h2>

<p>A problem description consists of four parts:</p>
<ol>
    <li> declarations of sorts, variables, standard names, and functions; </li>
    <li> optional abbreviations for formulas; </li>
    <li> the knowledge definition; </li>
    <li> entailment and/or consistency queries. </li>
</ol>
<p>
The syntax of these segments is as follows, where <span class="code">this font</span> is a word the problem description language, and <span class="metavariable">this font</span> represents a meta-variable.
</p>

<p>
All sorts, variables, names, and function symbols must be declared before they are used.
They are of the following form:
</p>
<ul class="grammar">
    <li><span class="code">Sort <span class="metavariable">sort</span>;</span>
    <li><span class="code">Variable <span class="metavariable">x</span> -&gt; <span class="metavariable">sort</span>;</span> &nbsp;&nbsp;or&nbsp;&nbsp;
        <span class="code">Var <span class="metavariable">x</span> -&gt; <span class="metavariable">sort</span>;</span></li>
    <li><span class="code">Name <span class="metavariable">n</span> -&gt; <span class="metavariable">sort</span>;</span></li>
    <li><span class="code">Function <span class="metavariable">f</span>/<span class="metavariable">arity</span> -&gt; <span class="metavariable">sort</span>;</span> &nbsp;&nbsp;or&nbsp;&nbsp;
        <span class="code">Fun <span class="metavariable">f</span>/<span class="metavariable">arity</span> -&gt; <span class="metavariable">sort</span>;</span></li>
</ul>
<p>
where <span class="metavariable">sort</span>, <span class="metavariable">x</span>, <span class="metavariable">n</span>, <span class="metavariable">f</span> are identifiers and <span class="metavariable">arity</span> is a natural number &ge; 0.
An identifier is a sequence of lower- and upper-case letters, digits, underscore and dash symbols, with the first symbol being a letter or underscore.
Sort identifiers must be declared before they are used in variable, name, or function declarations.
No two sorts can have the same identifier.
No two variables, names, or functions can have the same identifier.
</p>

<p>
The set of formulas includes literals, negated formulas, disjunctions, conjunctions, implications, equivalences, and existentially and universally quantified formulas, formulas in brackets, and abbreviations:
<ul class="grammar">
    <li><span class="code"><span class="metavariable">literal</span></span></li>
    <li><span class="code">!<span class="metavariable">formula</span></span> &nbsp;&nbsp;or&nbsp;&nbsp;
        <span class="code">~<span class="metavariable">formula</span></span></li>
    <li><span class="code"><span class="metavariable">formula<sub>1</sub></span> &amp;&amp; <span class="metavariable">formula<sub>2</sub></span></span> &nbsp;&nbsp;or&nbsp;&nbsp;
        <span class="code"><span class="metavariable">formula<sub>1</sub></span> &amp; <span class="metavariable">formula<sub>2</sub></span></span> &nbsp;&nbsp;or&nbsp;&nbsp;
        <span class="code"><span class="metavariable">formula<sub>1</sub></span> ^ <span class="metavariable">formula<sub>2</sub></span></span></li>
    <li><span class="code"><span class="metavariable">formula<sub>1</sub></span> || <span class="metavariable">formula<sub>2</sub></span></span> &nbsp;&nbsp;or&nbsp;&nbsp;
        <span class="code"><span class="metavariable">formula<sub>1</sub></span> | <span class="metavariable">formula<sub>2</sub></span></span> &nbsp;&nbsp;or&nbsp;&nbsp;
        <span class="code"><span class="metavariable">formula<sub>1</sub></span> v <span class="metavariable">formula<sub>2</sub></span></span></li>
    <li><span class="code"><span class="metavariable">formula<sub>1</sub></span> -&gt; <span class="metavariable">formula<sub>2</sub></span></span></li>
    <li><span class="code"><span class="metavariable">formula<sub>1</sub></span> &lt;-&gt; <span class="metavariable">formula<sub>2</sub></span></span></li>
    <li><span class="code">Ex <span class="metavariable">x</span> <span class="metavariable">formula</span></span></li>
    <li><span class="code">Fa <span class="metavariable">x</span> <span class="metavariable">formula</span></span></li>
    <li><span class="code">(<span class="metavariable">formula</span>)</span></li>
    <li><span class="code"><span class="metavariable">formula-id</span></span></li>
</ul>
<p>
where <span class="metavariable">literal</span> denotes a literal, which either an equality or an inequality expression:
</p>
<ul class="grammar">
    <li><span class="code"><span class="metavariable">t<sub>1</sub></span> == <span class="metavariable">t<sub>2</sub></span></span> &nbsp;&nbsp;or&nbsp;&nbsp;
        <span class="code"><span class="metavariable">t<sub>1</sub></span> = <span class="metavariable">t<sub>2</sub></span></span></li>
    <li><span class="code"><span class="metavariable">t<sub>1</sub></span> != <span class="metavariable">t<sub>2</sub></span></span> &nbsp;&nbsp;or&nbsp;&nbsp;
        <span class="code"><span class="metavariable">t<sub>1</sub></span> /= <span class="metavariable">t<sub>2</sub></span></span></li>
</ul>
<p>
where <span class="metavariable">t<sub>i</sub></span> is a term.
A term is either the identifier of a previously declared variable <span class="metavariable">x</span>, a standard name <span class="metavariable">n</span>, or a compound term <span class="code"><span class="metavariable">f</span>(<span class="metavariable">t'<sub>1</sub></span>, <span class="metavariable">...</span>, <span class="metavariable">t'<sub>k</sub></span>)</span> where a function
symbol <span class="metavariable">f</span> is applied to other terms <span class="metavariable">t'<sub>i</sub></span>.
When <span class="metavariable">f</span> is a constant symbol (that is, has arity 0), the brackets may be omitted.
Variables in the KB are implicitly universally quantified.
</p>
<p>
The identifiers of any variables <span class="metavariable">x</span>, standard names standard name <span class="metavariable">n</span>, function symbols <span class="metavariable">f</span>, or formula abbreviations <span class="metavariable">formula-id</span> must have been declared before they can be used in formulas.
</p>
<p>
Equivalence binds stronger than implication, implication binds stronger than conjunction, conjunction binds stronger than disjunction, and the scope of negation and quantifiers is minimal.
</p>

<p>
Any formula abbreviation <span class="metavariable">formula-id</span> must be defined before use:
</p>
<ul class="grammar">
    <li><span class="code">Let <span class="metavariable">formula-id</span> := <span class="metavariable">formula</span>;</span></li>
</ul>
<p>
where <span class="metavariable">formula-id</span> is the identifier by which the formula can later be referred.
The same identifier can be used for two different formulas; the semantics is that the latter definition overrides the former.
</p>

<p>
The knowledge base consists of a sequence of clauses, each of which is written (synonymously) as
</p>
<ul class="grammar">
    <li><span class="code">KB&nbsp;<span class="metavariable">formula</span>;</span></li>
</ul>
<p>
with the syntactic restriction that the <i>normal form</i> (explained below) of <span class="metavariable">formula</span> is a clause with leading universal quantifiers.
Furthermore, free variables in <span class="metavariable">formula</span> in KB definitions are implicitly universally quantified.
The definition of the normal form is tedious, but the idea is this: push negations inwards but not into clauses, and pull quantifiers out of clauses.
The rationale is to create new clauses (while avoiding the exponential blowup of a full CNF).
Additionally, terms are flattened so that no two function symbols occur in a any literal.
For instance, a disjunction <span class="code">KB&nbsp;(<span class="metavariable">literal<sub>1</sub></span> || <span class="metavariable">...</span> || <span class="metavariable">literal<sub>k</sub></span>);</span> meets this requirement trivially.
Implications are also allowed, provided that the negation of the antecedent as well as the consequent meet above form, as does <span class="code">KB&nbsp;(Ex <span class="metavariable">x</span> (<span class="metavariable">literal<sub>1</sub></span> &amp;&amp; <span class="metavariable">literal<sub>k</sub></span>) -&gt; (<span class="metavariable">literal<sub>1</sub></span> || <span class="metavariable">literal<sub>k</sub></span>));</span>.
</p>

<p>
Formulas can be used to query for entailment or consistency:
</p>
<ul class="grammar">
    <li><span class="code">Entails&nbsp;(<span class="metavariable">k</span>, <span class="metavariable">formula</span>);</span></li>
    <li><span class="code">Consistent&nbsp;(<span class="metavariable">k</span>, <span class="metavariable">formula</span>);</span></li>
</ul>
<p>
where <span class="metavariable">k</span> is a natural number &ge; 0 that denotes the reasoning effort and <span class="metavariable">formula</span> is a formula as defined above.
Both entailment and consistency queries are sound but incomplete with respect to classical logic.
The reasoning effort is measured in case splits (a split means to select a term <span class="code">f(n<sub>1</sub>,...,n<sub>l</sub>)</span> and consider all possible denotations of that term) in entailment queries, and as term assignments (an assignment means to select a term <span class="code">f(t<sub>1</sub>,...,t<sub>l</sub>)</span> and fix their denotation) in consistency queries.
The formula is brought into the <i>normal form</i> described above (roughly: push negations inwards but not inside clauses, pull quantifiers out of clauses, rewrite clauses so no literal contains two functions), which makes life easier for the reasoner.
</p>
<p>
For automated testing, the language supports assertions and refutations:
</p>
<ul class="grammar">
    <li><span class="code">Assert Entails&nbsp;(<span class="metavariable">k</span>, <span class="metavariable">formula</span>);</span></li>
    <li><span class="code">Refute Entails&nbsp;(<span class="metavariable">k</span>, <span class="metavariable">formula</span>);</span></li>
    <li><span class="code">Assert Consistent&nbsp;(<span class="metavariable">k</span>, <span class="metavariable">formula</span>);</span></li>
    <li><span class="code">Refute Consistent&nbsp;(<span class="metavariable">k</span>, <span class="metavariable">formula</span>);</span></li>
</ul>
<p>
Execution aborts with an asserted entailment/consistency does not hold or when a refuted entailment/consistency does hold.
</p>

<p>
C-style single line comments are supported as well: 
    <span class="code">//&nbsp;<span class="metavariable">rest of line is comment</span></span>.
</p>

<h2>References</h2>
<ul>
    <li>
        Lakemeyer and Levesque. Decidable Reasoning in a Logic of Limited Belief with Function Symbols. KR 2016.
        <a href="https://kbsg.rwth-aachen.de/sites/kbsg/files/LakemeyerLevesque2016.pdf">PDF</a></li>
    <li>
        Schwering and Lakemeyer. Decidable Reasoning in a First-Order Logic of Limited Conditional Belief. ECAI 2016.
        <a href="https://kbsg.rwth-aachen.de/sites/kbsg/files/SchweringLakemeyer2016.pdf">PDF</a>
    </li>
    <li>
        Lakemeyer and Levesque. Decidable Reasoning in a Fragment of the Epistemic Situation Calculus. KR 2014.
        <a href="https://pdfs.semanticscholar.org/8ac9/a2955895cd391ec2b62d8210ee8206979f4a.pdf">PDF</a>
    </li>
    <li>
        Lakemeyer and Levesque. Decidable Reasoning in a Logic of Limited Belief with Introspection and Unknown Individuals. IJCAI 2013.
        <a href="https://pdfs.semanticscholar.org/387c/951016c68aaf8ce36bb87e5ea4d1ef42405d.pdf">PDF</a>
    </li>
</ul>

</body>
</html>

