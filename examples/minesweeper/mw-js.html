<!DOCTYPE HTML>
<!-- vim:filetype=html:textwidth=200:shiftwidth=4:softtabstop=4:expandtab
-->
<html lang="en">
<head>
    <meta charset="UTF-8"> 
    <title>Limited reasoner demo</title>

    <!-- <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet"> -->
    <style type="text/css">
        body { font-family: 'Open Sans', sans-serif; font-size: 140%; }
        p { text-align: justify; }

        h1       { font-size: 220%; }
        h2       { font-size: 170%; border-bottom: 1px solid #aaa; }

        form .label { display: inline-block; min-width: 13em; }
        form input.number { width: 5em; }
        #play-button { background-color: black; color: #eee; font-family: inherit; font-weight: bold; font-size: 100%; margin-top: 1ex; margin-left: 1em; padding-left: 3em; padding-right: 3em; padding-top: 1ex; padding-bottom: 1ex; }
        #play-button {
            background:
                linear-gradient(27deg, #151515 5px, transparent 5px) 0 5px,
                linear-gradient(207deg, #151515 5px, transparent 5px) 10px 0px,
                linear-gradient(27deg, #222 5px, transparent 5px) 0px 10px,
                linear-gradient(207deg, #222 5px, transparent 5px) 10px 5px,
                linear-gradient(90deg, #1b1b1b 10px, transparent 10px),
                linear-gradient(#1d1d1d 25%, #1a1a1a 25%, #1a1a1a 50%, transparent 50%, transparent 75%, #242424 75%, #242424);
            background-color: #131313;
            background-size: 20px 20px;
        }

        #output #status { }
        div.table { display: table; overflow: scroll; }
        div.table div.row { display: table-row; }
        div.table div.row div.header,
        div.table div.row div.cell { display: table-cell; width: 2em; min-width: 2em; height: 2em; text-align: center; vertical-align: middle; padding: 0; margin: 0; overflow: hidden; }
        div.table div.row div.header { background-color: #cecece; }
        div.table div.row div.cell { border: 1px solid black; border-bottom: 2px solid black; }
        div.table div.row div.cell.new { font-weight: bold; }
        div.table div.row div.cell.mistake { color: red; font-weight: bold; }

        #output span { }
        #output span.black { color: black; }
        #output span.dim { color: #999; }
        #output span.reset { color: inherit; }
        #output span.red { color: red; font-weight: bold; }
        #output span.green { color: green; font-weight: bold; }
    </style>

    <script src="jquery-3.1.1.min.js"></script>
    <script src="mw-js.js"></script>
</head>

<body>

<h1>Limited Reasoner Demo: Minesweeper</h1>

<p>
<b>Quick start:</b> choose a "Game Configuration", hit the "Click me!" button, and see the agent play under "Game Output".
</p>

<p>
For further demos and details on the reasoner, <a href="../">click here</a>.
</p>

<h2>Game Configuration</h2>

<p>Standard configurations:
	<a id="config-small" href="#config-small">small</a>,
	<a id="config-medium" href="#config-medium">medium</a>,
	<a id="config-large" href="#config-large">large</a>,
	<a id="config-huge" href="#config-huge">huge</a>
</p>

<form>
<div class="label">Field width:</div> <input type="number" id="width" min="0" class="number"><br />
<div class="label">Field height:</div> <input type="number" id="height" min="0" class="number"><br />
<div class="label">Number of mines:</div> <input type="number" id="n_mines" min="0" class="number"><br />
<div style="height: 1ex;"></div>
<div class="label">Max. number of case splits:</div> <input type="number" id="max_k" min="0" value="2" class="number"><br />
<div class="label">Mine placement seed:</div> <input type="number" id="seed" min="0" value="1" class="number"> (modify for different mine placement)<br />
<input id="play-button" type="button" value="Click me!" />
</form>

<script>
$(document).ready(function() {
    $('#config-small').click(function() { setConfig(8, 8, 10); return false; }).click();
    $('#config-medium').click(function() { setConfig(16, 16, 40); return false; });
    $('#config-large').click(function() { setConfig(32, 16, 99); return false; });
    $('#config-huge').click(function() { setConfig(64, 32, 320); return false; });
    $('#play-button').click(function() { play(); });
    $('#play-button').focus();
    $('#width').change(function() { initDisplay(); });
    $('#height').change(function() { initDisplay(); });
    $('#different-seed').click(function() { $('#seed').val(parseInt($('#seed').val()) + 1); return true; });
    $('#different-seed-msg').hide();
    initDisplay();
});

function setConfig(width, height, n_mines) {
    document.getElementById('width').value = width;
    document.getElementById('height').value = height;
    document.getElementById('n_mines').value = n_mines;
    initDisplay();
}

var t0 = null;

function play() {
    var width = document.getElementById('width').value;
    if (width == null) width = 8;
    var height = document.getElementById('height').value;
    if (height == null) height = 8;
    var n_mines = document.getElementById('n_mines').value;
    if (n_mines == null) n_mines = 10;
    var seed = document.getElementById('seed').value;
    if (seed == null) n_mines = 0;
    var max_k = document.getElementById('max_k').value;
    if (max_k == null) max_k = 0;

    t0 = performance.now();
    Module.ccall('lela_init', 'void', ['number', 'number', 'number', 'number', 'number'], [width, height, n_mines, seed, max_k]);
    playTurn();
    setTimeout(function() { scrollDown(); }, 50);
    setTimeout(function() { scrollDown(); }, 100);
}

function playTurn() {
    setTimeout(function() {
        var game_over = Module.ccall('lela_play_turn', 'number', [], []);
        if (!game_over) {
            playTurn();
        } else {
            updateStatusGameOver();
            var t1 = performance.now();
            console.log("Playing and printing took "+ Math.round(t1 - t0) +" milliseconds");
        }
    }, 0);
}

function cellId(x, y) {
    return 'cell_'+ x +'_'+ y;
}

var width = -1;
var height = -1;
var games = [];
var current_game = -1;

function cell(x, y) {
    return $('#'+ cellId(x, y));
}

function initDisplay() {
    width = document.getElementById('width').value;
    if (width == null) width = 8;
    height = document.getElementById('height').value;
    if (height == null) height = 8;

    var output = $('#output');
    output.empty();
    games = [];
    current_game = -1;

    output.append('<div class="table"></div>');
    var table = $('#output').children().last();
    {
        table.append('<div class="row"></div>');
        var row = table.children().last();
        row.append('<div class="header">&nbsp;</div>');
        var x;
        for (x = 0; x < width; ++x) {
            row.append('<div class="header">'+ x +'</div>');
        }
    }
    var y;
    for (y = 0; y < height; ++y) {
        table.append('<div class="row"></div>');
        var row = table.children().last();
        row.append('<div class="header">'+ y +'</div>');
        var x;
        for (x = 0; x < width; ++x) {
            row.append('<div id="'+ cellId(x, y) +'" class="cell">&nbsp;</div>');
        }
    }
}

function updateStatus(msg) {
    $('#status').html(msg);
    $('#different-seed-msg').hide();
}

function updateStatusGameOver() {
    if (games[current_game].indexOf(' ') == -1) {
        updateStatus('<span style="color: green; font-weight: bold;">We won :-)</span>');
        $('#different-seed-msg').show();
    } else {
        displayGame(current_game, true);
        updateStatus('<span style="color: red; font-weight: bold;">We lost :-(</span>');
        $('#different-seed-msg').show();
    }
}

function displayGame(arg, mistake) {
    if (typeof arg === 'string') {
        games.push(arg);
        current_game = games.length - 1;
    } else if (typeof arg === 'number') {
        current_game = arg;
        if (current_game < 0) {
            current_game = 0;
        }
        if (current_game >= games.length) {
            current_game = games.length - 1;
        }
    }
    var p = current_game > 0 ? games[current_game - 1] : null;
    var g = games[current_game];
    var i;
    for (i = 0; i < g.length; ++i) {
        var c = g[i];
        if (c == ' ') { c = "&nbsp;" }
        if (c == '.') { c = "&middot;" }
        var x = i % width;
        var y = Math.floor(i / width);
        cell(x, y).html(c);
        if (p != null && p[i] != g[i]) {
            var x = i % width;
            var y = Math.floor(i / width);
            cell(x, y).addClass('new');
            if (mistake) {
                cell(x, y).addClass('mistake');
            }
        } else {
            cell(x, y).removeClass('new');
            cell(x, y).removeClass('mistake');
        }
    }
}

function scrollDown() {
    document.getElementById('field-next').scrollIntoView(false);
}

$(document).ready(function() {
    $('#field-prev').click(function() { displayGame(current_game - 1); return false; });
    $('#field-next').click(function() { displayGame(current_game + 1); return false; });
});
$(document).keydown(function(e) {
    switch(e.which) {
        case 37: displayGame(current_game - 1); break; // left
        case 39: displayGame(current_game + 1); break; // right
        default: return;
    }
    e.preventDefault();
});
</script>



<h2>Game Output</h2>

<p>
<div id="status" style="display: inline;">Ready to play!</div>
<div id="different-seed-msg" style="padding-left: 1ex; display: inline;">Would you like to try again? Change the <a id="different-seed" href="#play-button" style="display: inline;">mine placement seed</a> or the <a href="#config-small">field size</a>!</div>
</p>

<div id="output"></div>

<p>
<b>Quick explanation:</b>
The agent aims to explore the field without hitting a mine.
When it opens a mine-free cell, it learns how many adjacent cells contain a mine.
This number is displayed in every cell (except for <code>0</code>, which instead is visualised by a dot).
A green <code style="color: green; font-weight: bold;">X</code> represents a cell the agent has reasoned out to contain a mine.
</p>

<p>See <a href="#field-prev" id="field-prev">previous</a> / <a href="#field-next" id="field-next">next</a> turn (or use arrow keys &#x21e6; &#x21e8;).



<h2>About Minesweeper</h2>

<p>
Among the <code>width</code> &times; <code>height</code> cells on the field, <code>n_mines</code> cells contain a mine. The goal of the agent is to identify these mines.
</p>

<p>
On every turn, the player selects a cell and either explores it or flags it as mine.
Exploring a cell tells the agent how many adjacent cells (0 &le; N &le; 8) contain mines.
(When N = 0, the adjacent cells are explored immediately.)
Flagging a cell does not tell the agent anything, it's more of a mental note not to explore the cell.
Explored fields are visualized as their number <code>N</code> or by a <code>.</code> symbol when N = 0; flagged cells are marked by a <code style="color: green; font-weight: bold;">X</code> symbol.
</p>

<p>
The game is won when all non-mine fields are explored and all mine cells are flagged. The game is lost when the agent explores a mine cell.
</p>



<h2>About the Agent</h2>

<p>
The agent is a simple C++ program that loops over all cells and uses the reasoner to find out which cells are known to contain a/no mine.
</p>

<p>
For every cell <code>(x,y)</code>, we use a proposition <code>IsMine(x,y)</code>.
When a cell is explored, the agent receives the information how many adjacent cells contain a mine.
To reflect this new information, the agent adds clauses of <code>IsMine(x,y)</code>.
For instance, when the agent learns that one of the eight adjacent cell contains a mine, it adds <code>IsMine(x-1,y) &or; IsMine(x-1,y+1) &or; IsMine(x,y+1) &or; IsMine(x+1,y+1) &or; IsMine(x+1,y) &or; IsMine(x+1,y-1) &or; IsMine(x,y-1) &or; IsMine(x-1,y-1)</code> to say that at least one of the neighbours contains a mine, and a few similar clauses to say that at least seven adjacent cells contain <i>no</i> mine.
</p>

<p>
On every turn, the agent checks for every cell whether it is known to contain a mine or known to contain no mine.
(As a simple heuristic, the agent starts with cells in the neighbourhood of the cell selected in the last move.)
This process is repeated for increasing split level, until a cell which is known to be a mine or known to be safe is found: first for split level 0, then for 1, ..., until the maximum specified split level.
If no cell is found, the agent guesses one randomly.
</p>

<p>
Note the agent's actions are not represented in the knowledge base &ndash; it's just hard-coded in C++.
Extending the knowledge base to a basic action theory that also represents the agent's actions would be the next step.
</p>

<p>
The runtime reported by the game refers to the time the agent actually spend playing.
The actual time that passes between starting and finishing the game may be longer because the graphical display procedures take some time.
</p>

</body>
</html>

