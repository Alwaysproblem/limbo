<!DOCTYPE HTML>
<html lang="en">
<head>
    <meta charset="UTF-8"> 
    <title>Limited reasoner demo</title>

    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
    <style type="text/css">
        body { font-family: 'Open Sans', sans-serif; font-size: 140%; }
        p { text-align: justify; }

        h1       { font-size: 220%; }
        h2       { font-size: 170%; border-bottom: 1px solid #aaa; }

        form .label { display: inline-block; min-width: 7em; }
        form input.number { width: 5em; }
        #play-button { background-color: black; color: #eee; font-family: inherit; font-weight: bold; font-size: 100%; margin-top: 1ex; margin-left: 1em; padding-left: 3em; padding-right: 3em; padding-top: 1ex; padding-bottom: 1ex; }
        #play-button {
            background:
                linear-gradient(27deg, #151515 5px, transparent 5px) 0 5px,
                linear-gradient(207deg, #151515 5px, transparent 5px) 10px 0px,
                linear-gradient(27deg, #222 5px, transparent 5px) 0px 10px,
                linear-gradient(207deg, #222 5px, transparent 5px) 10px 5px,
                linear-gradient(90deg, #1b1b1b 10px, transparent 10px),
                linear-gradient(#1d1d1d 25%, #1a1a1a 25%, #1a1a1a 50%, transparent 50%, transparent 75%, #242424 75%, #242424);
            background-color: #131313;
            background-size: 20px 20px;
        }

        #output { width: 95%; min-height: 5ex; background-color: #dddddd; border: 2px solid black; white-space: pre; }
        #output { background: repeating-linear-gradient( 45deg, #e5e5e5, #e5e5e5 10px, #eeeeee 10px, #eeeeee 20px); }
        #output { font-family: monospace; font-size: 110%; }

        #output span.black { color: black; }
        #output span.dim { color: #999; }
        #output span.reset { color: inherit; }
        #output span.red { color: red; font-weight: bold; }
        #output span.green { color: green; font-weight: bold; }
    </style>

    <script src="lela.js"></script>
</head>

<body onload="initPage()">

<h1>Limited Reasoner Demo: Minesweeper</h1>

<p>
This is demo of a limited reasoner for <b>decidable reasoning in first-order knowledge bases</b>.
</p>

<p>
<b>Quick start:</b> have a look at the "Problem Description", hit the "Click me!" button, and check the output under "Reasoning Results".
</p>

<p>
Also have a look at the <a href="../ti/" target="_blank">the other demo: text interface</a>.
</p>

<h2>Game Configuration</h2>

<p>Standard configurations: <a href="javascript:setConfig(8,8,10);">small</a>, <a href="javascript:setConfig(16,16,40);">medium</a>, <a href="javascript:setConfig(16,32,99);">large</a>, <a href="javascript:setConfig(32,64,320);">huge</a> </p>

<form>
<div class="label">Width:</div> <input type="number" id="width" min="0" value="8" class="number"><br />
<div class="label">Height:</div> <input type="number" id="height" min="0" value="8" class="number"><br />
<div class="label">Mines:</div> <input type="number" id="n_mines" min="0" value="10" class="number"><br />
<div class="label">Seed:</div> <input type="number" id="seed" min="0" value="0" class="number"><br />
<div class="label">Max. splits:</div> <input type="number" id="max_k" min="0" value="2" class="number"><br />
<input id="play-button" type="button" value="Click me!" onclick="play()" />
</form>

<script>
function setConfig(width, height, n_mines) {
    console.log('test');
    document.getElementById('width').value = width;
    document.getElementById('height').value = height;
    document.getElementById('n_mines').value = n_mines;
}

function clearDiv(id) {
    var div = document.getElementById(id);
    while (div.firstChild) {
        div.removeChild(div.firstChild);
    }
}

function play() {
    clearDiv('output');

    var width = document.getElementById('width').value;
    if (width == null) width = 8;
    var height = document.getElementById('height').value;
    if (height == null) height = 8;
    var n_mines = document.getElementById('n_mines').value;
    if (n_mines == null) n_mines = 10;
    var seed = document.getElementById('seed').value;
    if (seed == null) n_mines = 0;
    var max_k = document.getElementById('max_k').value;
    if (max_k == null) n_mines = 0;

    Module.ccall('lela_init', 'void', ['number', 'number', 'number', 'numer', 'numer'], [width, height, n_mines, seed, max_k]);
    play_turn();
}

function play_turn() {
    setTimeout(function() {
        var game_over = Module.ccall('lela_play_turn', 'number', [], []);
        scrollDown();
        if (!game_over)
            play_turn();
    }, 5);
}

function scrollDown() {
    var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
    if (false && isFirefox) {
        document.getElementById('output').scrollIntoView({block: "end", behavior: "smooth"});
    } else {
        document.getElementById('output').scrollIntoView(false);
    }
}

function printLine(str) {
    setTimeout(function() {
        var output = document.getElementById('output');
        if (str.length == 0) {
            return;
        }
        var div = document.createElement('div');
        div.innerHTML = str;
        output.appendChild(div);
        scrollDown();
    }, 10);
}

function initPage() {
    //var text = document.getElementById('seed');
    //text.focus();
}
</script>



<h2>Game Output</h2>

<div id="output"></div>



<h2>About the Reasoner</h2>

<p>
The logical language features functions and equality, first-order quantification, standard names, and sorts.
(Predicates are not built-in but can be simulated with no overhead using boolean functions.)
Knowledge bases are restricted to be in clausal form with only universally quantified variables &ndash; these KBs are called proper<sup>+</sup>.
(Existentially quantified variables in the knowledge base can be simulated with functions.)
Queries are not subject to any syntactic restriction.
</p>

<p>
Decision procedures for sound entailment [KR-2016] and sound consistency [ECAI-2016] are implemented.
Future work are the conditional beliefs [ECAI-2016] (should be easy), actions [KR-2014] [ (as a preprocessing step), and introspection [IJCAI-2013].
</p>

<p>
The reasoner is written in C++.
The code is available at <a href="https://www.github.com/schwering/lela">github.com/schwering/lela</a>.
This demo is compiled by <a href="http://emscripten.org">emscripten</a>, which compiles C++ to Javascript.
The performance of the Javascript is about 10&times; slower than the native performance (on my computer, anyway).
(Which is funny, it should be only about 2&times; slower according to the times reported at the emscripten website.)
</p>

<p>
Please report bugs to <a href="mailto:c.schwering@unsw.edu.au">c.schwering@unsw.edu.au</a>.
</p>



<h2>About Minesweeper</h2>

<p>Among the <code>width</code> &times; <code>height</code> cells on the field, <code>n_mines</code> cells contain mines. The goal of the agent is to identify these mines. Every turn, the agent can select a cell and explore it, in which case it learns how many of the adjacent cells contain a mine, or flag it as mine. The game is won when all non-mine fields are explored and all mine cells are flagged. The game is lost when the agent explores a mine cell.</p>



<h2>About the Agent</h2>

<p>The agent is a simple C++ program that loops over all cells and uses the reasoner to find out which cells are known to contain a/no mine.</p>

<p>For every cell <code>(x,y)</code>, we use a proposition <code>IsMine(x,y)</code>. When a cell is explored, the agent receives the information how many adjacent cells contain a mine. To reflect this new information, the agent adds clauses of <code>IsMine(x,y)</code>. For instance, when the agent learns that one of the eight adjacent cell contains a mine, it adds <code>IsMine(x-1,y) &or; IsMine(x-1,y+1) &or; IsMine(x,y+1) &or; IsMine(x+1,y+1) &or; IsMine(x+1,y) &or; IsMine(x+1,y-1) &or; IsMine(x,y-1) &or; IsMine(x-1,y-1)</code> to say that at least one of the neighbors contains a mine, and a few similar clauses to say that at least seven adjacent cells contain <i>no</i> mine.</p>

<p>On every turn, the agent checks for every cell whether it is known to contain a mine or known to contain no mine. This process is repeated for increasing slit level, until a cell which is known to be a mine or known to be safe is found: first for split level 0, then for 1, ..., until the maximum specified split level. If no cell is found, the agent guesses one randomly.</p>

<p>Note the agent's actions are not represented in the knowledge base -- it's just hard-coded in C++. Extending the knowledge base to a basic action theory that also represents the agent's actions would be the next step.</p>



<h2>References</h2>
<ul>
    <li>
        Lakemeyer and Levesque. Decidable Reasoning in a Logic of Limited Belief with Function Symbols. KR 2016.
        <a href="https://kbsg.rwth-aachen.de/sites/kbsg/files/LakemeyerLevesque2016.pdf">PDF</a></li>
    <li>
        Schwering and Lakemeyer. Decidable Reasoning in a First-Order Logic of Limited Conditional Belief. ECAI 2016.
        <a href="https://kbsg.rwth-aachen.de/sites/kbsg/files/SchweringLakemeyer2016.pdf">PDF</a>
    </li>
    <li>
        Lakemeyer and Levesque. Decidable Reasoning in a Fragment of the Epistemic Situation Calculus. KR 2014.
        <a href="https://pdfs.semanticscholar.org/8ac9/a2955895cd391ec2b62d8210ee8206979f4a.pdf">PDF</a>
    </li>
    <li>
        Lakemeyer and Levesque. Decidable Reasoning in a Logic of Limited Belief with Introspection and Unknown Individuals. IJCAI 2013.
        <a href="https://pdfs.semanticscholar.org/387c/951016c68aaf8ce36bb87e5ea4d1ef42405d.pdf">PDF</a>
    </li>
</ul>

</body>
</html>

